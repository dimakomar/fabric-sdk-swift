/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: orderer/orderer_configuration.proto
 *
 */

// 
// Copyright IBM Corp. 2016 All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _1: SwiftProtobuf.ProtobufAPIVersion_1 {}
  typealias Version = _1
}

//  The orderer config is specified by the following convention:
//    For a configuration item with key "Key"
//    the encoded value is a a proto message of type "Key"
//    For example, for the configuration item of name "ConsensusType"
//    the encoded value is the proto message "ConsensusType"

struct Orderer_ConsensusType: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ConsensusType"
  static let protoPackageName: String = "orderer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  var type: String = ""

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularStringField(value: &type)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !type.isEmpty {
      try visitor.visitSingularStringField(value: type, fieldNumber: 1)
    }
  }

  func _protobuf_generated_isEqualTo(other: Orderer_ConsensusType) -> Bool {
    if type != other.type {return false}
    return true
  }
}

struct Orderer_BatchSize: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BatchSize"
  static let protoPackageName: String = "orderer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "maxMessageCount"),
    2: .same(proto: "absoluteMaxBytes"),
    3: .same(proto: "preferredMaxBytes"),
  ]

  ///   Simply specified as number of messages for now, in the future
  ///   we may want to allow this to be specified by size in bytes
  var maxMessageCount: UInt32 = 0

  ///   The byte count of the serialized messages in a batch cannot
  ///   exceed this value.
  var absoluteMaxBytes: UInt32 = 0

  ///   The byte count of the serialized messages in a batch should not
  ///   exceed this value.
  var preferredMaxBytes: UInt32 = 0

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularUInt32Field(value: &maxMessageCount)
    case 2: try decoder.decodeSingularUInt32Field(value: &absoluteMaxBytes)
    case 3: try decoder.decodeSingularUInt32Field(value: &preferredMaxBytes)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if maxMessageCount != 0 {
      try visitor.visitSingularUInt32Field(value: maxMessageCount, fieldNumber: 1)
    }
    if absoluteMaxBytes != 0 {
      try visitor.visitSingularUInt32Field(value: absoluteMaxBytes, fieldNumber: 2)
    }
    if preferredMaxBytes != 0 {
      try visitor.visitSingularUInt32Field(value: preferredMaxBytes, fieldNumber: 3)
    }
  }

  func _protobuf_generated_isEqualTo(other: Orderer_BatchSize) -> Bool {
    if maxMessageCount != other.maxMessageCount {return false}
    if absoluteMaxBytes != other.absoluteMaxBytes {return false}
    if preferredMaxBytes != other.preferredMaxBytes {return false}
    return true
  }
}

struct Orderer_BatchTimeout: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BatchTimeout"
  static let protoPackageName: String = "orderer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timeout"),
  ]

  ///   Any duration string parseable by ParseDuration():
  ///   https://golang.org/pkg/time/#ParseDuration
  var timeout: String = ""

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularStringField(value: &timeout)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !timeout.isEmpty {
      try visitor.visitSingularStringField(value: timeout, fieldNumber: 1)
    }
  }

  func _protobuf_generated_isEqualTo(other: Orderer_BatchTimeout) -> Bool {
    if timeout != other.timeout {return false}
    return true
  }
}

///   When submitting a new chain configuration transaction to create a new chain,
///   the first configuration item must be of type Orderer with Key CreationPolicy
///   and contents of a Marshaled CreationPolicy. The policy should be set to the
///   policy which was supplied by the ordering service for the client's chain
///   creation. The digest should be the hash of the concatenation of the remaining
///   ConfigurationItem bytes. The signatures of the configuration item should
///   satisfy the policy for chain creation.
struct Orderer_CreationPolicy: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CreationPolicy"
  static let protoPackageName: String = "orderer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "policy"),
  ]

  ///   The name of the policy which should be used to validate the creation of
  ///   this chain
  var policy: String = ""

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularStringField(value: &policy)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !policy.isEmpty {
      try visitor.visitSingularStringField(value: policy, fieldNumber: 1)
    }
  }

  func _protobuf_generated_isEqualTo(other: Orderer_CreationPolicy) -> Bool {
    if policy != other.policy {return false}
    return true
  }
}

///   ChainCreationPolicyNames is the set of policies which may be invoked for chain creation
struct Orderer_ChainCreationPolicyNames: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChainCreationPolicyNames"
  static let protoPackageName: String = "orderer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "names"),
  ]

  ///   A list of policies, in evaluation these are 'or'-ed, note this is not a proper policy
  ///   because implementing referential policies in a general way is difficult, and dangerous
  var names: [String] = []

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeRepeatedStringField(value: &names)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !names.isEmpty {
      try visitor.visitRepeatedStringField(value: names, fieldNumber: 1)
    }
  }

  func _protobuf_generated_isEqualTo(other: Orderer_ChainCreationPolicyNames) -> Bool {
    if names != other.names {return false}
    return true
  }
}

///   Carries a list of bootstrap brokers, i.e. this is not the exclusive set of
///   brokers an ordering service
struct Orderer_KafkaBrokers: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "KafkaBrokers"
  static let protoPackageName: String = "orderer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "brokers"),
  ]

  ///   Each broker here should be identified using the (IP|host):port notation,
  ///   e.g. 127.0.0.1:7050, or localhost:7050 are valid entries
  var brokers: [String] = []

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeRepeatedStringField(value: &brokers)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !brokers.isEmpty {
      try visitor.visitRepeatedStringField(value: brokers, fieldNumber: 1)
    }
  }

  func _protobuf_generated_isEqualTo(other: Orderer_KafkaBrokers) -> Bool {
    if brokers != other.brokers {return false}
    return true
  }
}

///   ChannelRestrictions is the mssage which conveys restrictions on channel creation for an orderer
struct Orderer_ChannelRestrictions: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChannelRestrictions"
  static let protoPackageName: String = "orderer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "max_count", json: "maxCount"),
  ]

  ///   The max count of channels to allow to be created, a value of 0 indicates no limit
  var maxCount: UInt64 = 0

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularUInt64Field(value: &maxCount)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if maxCount != 0 {
      try visitor.visitSingularUInt64Field(value: maxCount, fieldNumber: 1)
    }
  }

  func _protobuf_generated_isEqualTo(other: Orderer_ChannelRestrictions) -> Bool {
    if maxCount != other.maxCount {return false}
    return true
  }
}

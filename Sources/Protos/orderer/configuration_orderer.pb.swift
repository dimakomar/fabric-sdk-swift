/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: orderer/configuration.proto
 *
 */

// 
// Copyright IBM Corp. 2016 All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf


//  The orderer config is specified by the following convention:
//    For a configuration item with key "Key"
//    the encoded value is a a proto message of type "Key"
//    For example, for the configuration item of name "ConsensusType"
//    the encoded value is the proto message "ConsensusType"

struct Orderer_ConsensusType: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Orderer_ConsensusType"}
  public var protoMessageName: String {return "ConsensusType"}
  public var protoPackageName: String {return "orderer"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "type", swift: "type"),
  ]


  var type: String = ""

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &type)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if type != "" {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: type, fieldNumber: 1)
    }
  }

  public func _protoc_generated_isEqualTo(other: Orderer_ConsensusType) -> Bool {
    if type != other.type {return false}
    return true
  }
}

struct Orderer_BatchSize: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Orderer_BatchSize"}
  public var protoMessageName: String {return "BatchSize"}
  public var protoPackageName: String {return "orderer"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "maxMessageCount", swift: "maxMessageCount"),
    2: .same(proto: "absoluteMaxBytes", swift: "absoluteMaxBytes"),
    3: .same(proto: "preferredMaxBytes", swift: "preferredMaxBytes"),
  ]


  ///   Simply specified as number of messages for now, in the future
  ///   we may want to allow this to be specified by size in bytes
  var maxMessageCount: UInt32 = 0

  ///   The byte count of the serialized messages in a batch cannot
  ///   exceed this value.
  var absoluteMaxBytes: UInt32 = 0

  ///   The byte count of the serialized messages in a batch should not
  ///   exceed this value.
  var preferredMaxBytes: UInt32 = 0

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufUInt32.self, value: &maxMessageCount)
    case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufUInt32.self, value: &absoluteMaxBytes)
    case 3: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufUInt32.self, value: &preferredMaxBytes)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if maxMessageCount != 0 {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufUInt32.self, value: maxMessageCount, fieldNumber: 1)
    }
    if absoluteMaxBytes != 0 {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufUInt32.self, value: absoluteMaxBytes, fieldNumber: 2)
    }
    if preferredMaxBytes != 0 {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufUInt32.self, value: preferredMaxBytes, fieldNumber: 3)
    }
  }

  public func _protoc_generated_isEqualTo(other: Orderer_BatchSize) -> Bool {
    if maxMessageCount != other.maxMessageCount {return false}
    if absoluteMaxBytes != other.absoluteMaxBytes {return false}
    if preferredMaxBytes != other.preferredMaxBytes {return false}
    return true
  }
}

struct Orderer_BatchTimeout: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Orderer_BatchTimeout"}
  public var protoMessageName: String {return "BatchTimeout"}
  public var protoPackageName: String {return "orderer"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "timeout", swift: "timeout"),
  ]


  ///   Any duration string parseable by ParseDuration():
  ///   https://golang.org/pkg/time/#ParseDuration
  var timeout: String = ""

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &timeout)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if timeout != "" {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: timeout, fieldNumber: 1)
    }
  }

  public func _protoc_generated_isEqualTo(other: Orderer_BatchTimeout) -> Bool {
    if timeout != other.timeout {return false}
    return true
  }
}

///   When submitting a new chain configuration transaction to create a new chain,
///   the first configuration item must be of type Orderer with Key CreationPolicy
///   and contents of a Marshaled CreationPolicy. The policy should be set to the
///   policy which was supplied by the ordering service for the client's chain
///   creation. The digest should be the hash of the concatenation of the remaining
///   ConfigurationItem bytes. The signatures of the configuration item should
///   satisfy the policy for chain creation.
struct Orderer_CreationPolicy: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Orderer_CreationPolicy"}
  public var protoMessageName: String {return "CreationPolicy"}
  public var protoPackageName: String {return "orderer"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "policy", swift: "policy"),
  ]


  ///   The name of the policy which should be used to validate the creation of
  ///   this chain
  var policy: String = ""

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &policy)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if policy != "" {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: policy, fieldNumber: 1)
    }
  }

  public func _protoc_generated_isEqualTo(other: Orderer_CreationPolicy) -> Bool {
    if policy != other.policy {return false}
    return true
  }
}

///   IngressPolicyNames is the set of policy names which incoming Broadcast signatures are filtered against
struct Orderer_IngressPolicyNames: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Orderer_IngressPolicyNames"}
  public var protoMessageName: String {return "IngressPolicyNames"}
  public var protoPackageName: String {return "orderer"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "names", swift: "names"),
  ]


  ///   A list of policies, in evaluation these are 'or'-ed, note this is not a proper policy
  ///   because implementing referential policies in a general way is difficult, and dangerous
  var names: [String] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeRepeatedField(fieldType: SwiftProtobuf.ProtobufString.self, value: &names)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if !names.isEmpty {
      try visitor.visitRepeatedField(fieldType: SwiftProtobuf.ProtobufString.self, value: names, fieldNumber: 1)
    }
  }

  public func _protoc_generated_isEqualTo(other: Orderer_IngressPolicyNames) -> Bool {
    if names != other.names {return false}
    return true
  }
}

///   EgressPolicyNames is the set of policy names which incoming Deliver signatures are filtered against
struct Orderer_EgressPolicyNames: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Orderer_EgressPolicyNames"}
  public var protoMessageName: String {return "EgressPolicyNames"}
  public var protoPackageName: String {return "orderer"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "names", swift: "names"),
  ]


  ///   A list of policies, in evaluation these are 'or'-ed, note this is not a proper policy
  ///   because implementing referential policies in a general way is difficult, and dangerous
  var names: [String] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeRepeatedField(fieldType: SwiftProtobuf.ProtobufString.self, value: &names)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if !names.isEmpty {
      try visitor.visitRepeatedField(fieldType: SwiftProtobuf.ProtobufString.self, value: names, fieldNumber: 1)
    }
  }

  public func _protoc_generated_isEqualTo(other: Orderer_EgressPolicyNames) -> Bool {
    if names != other.names {return false}
    return true
  }
}

///   ChainCreationPolicyNames is the set of policies which may be invoked for chain creation
struct Orderer_ChainCreationPolicyNames: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Orderer_ChainCreationPolicyNames"}
  public var protoMessageName: String {return "ChainCreationPolicyNames"}
  public var protoPackageName: String {return "orderer"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "names", swift: "names"),
  ]


  ///   A list of policies, in evaluation these are 'or'-ed, note this is not a proper policy
  ///   because implementing referential policies in a general way is difficult, and dangerous
  var names: [String] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeRepeatedField(fieldType: SwiftProtobuf.ProtobufString.self, value: &names)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if !names.isEmpty {
      try visitor.visitRepeatedField(fieldType: SwiftProtobuf.ProtobufString.self, value: names, fieldNumber: 1)
    }
  }

  public func _protoc_generated_isEqualTo(other: Orderer_ChainCreationPolicyNames) -> Bool {
    if names != other.names {return false}
    return true
  }
}

///   Carries a list of bootstrap brokers, i.e. this is not the exclusive set of
///   brokers an ordering service
struct Orderer_KafkaBrokers: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Orderer_KafkaBrokers"}
  public var protoMessageName: String {return "KafkaBrokers"}
  public var protoPackageName: String {return "orderer"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "brokers", swift: "brokers"),
  ]


  ///   Each broker here should be identified using the (IP|host):port notation,
  ///   e.g. 127.0.0.1:7050, or localhost:7050 are valid entries
  var brokers: [String] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeRepeatedField(fieldType: SwiftProtobuf.ProtobufString.self, value: &brokers)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if !brokers.isEmpty {
      try visitor.visitRepeatedField(fieldType: SwiftProtobuf.ProtobufString.self, value: brokers, fieldNumber: 1)
    }
  }

  public func _protoc_generated_isEqualTo(other: Orderer_KafkaBrokers) -> Bool {
    if brokers != other.brokers {return false}
    return true
  }
}

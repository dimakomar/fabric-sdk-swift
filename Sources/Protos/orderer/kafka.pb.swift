/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: orderer/kafka.proto
 *
 */

// 
// Copyright IBM Corp. 2016 All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf


///   KafkaMessage is a wrapper type for the messages
///   that the Kafka-based orderer deals with.
struct Orderer_KafkaMessage: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Orderer_KafkaMessage"}
  public var protoMessageName: String {return "KafkaMessage"}
  public var protoPackageName: String {return "orderer"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "regular", swift: "regular"),
    2: .unique(proto: "time_to_cut", json: "timeToCut", swift: "timeToCut"),
    3: .same(proto: "connect", swift: "connect"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Orderer_KafkaMessage
    var _type = Orderer_KafkaMessage.OneOf_Type()

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1, 2, 3: try _type.decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      try _type.traverse(visitor: visitor, start: 1, end: 4)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _type != other._type {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._type = _type
      return clone
    }
  }

  private var _storage = _StorageClass()


  enum OneOf_Type: ExpressibleByNilLiteral, SwiftProtobuf.OneofEnum {
    case regular(Orderer_KafkaMessageRegular)
    case timeToCut(Orderer_KafkaMessageTimeToCut)
    case connect(Orderer_KafkaMessageConnect)
    case None

    static func ==(lhs: Orderer_KafkaMessage.OneOf_Type, rhs: Orderer_KafkaMessage.OneOf_Type) -> Bool {
      switch (lhs, rhs) {
      case (.regular(let l), .regular(let r)): return l == r
      case (.timeToCut(let l), .timeToCut(let r)): return l == r
      case (.connect(let l), .connect(let r)): return l == r
      case (.None, .None): return true
      default: return false
      }
    }

    public init(nilLiteral: ()) {
      self = .None
    }

    public init() {
      self = .None
    }

    public mutating func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      if self != .None && setter.rejectConflictingOneof {
        throw SwiftProtobuf.DecodingError.duplicatedOneOf
      }
      switch protoFieldNumber {
      case 1:
        var value: Orderer_KafkaMessageRegular?
        try setter.decodeSingularMessageField(fieldType: Orderer_KafkaMessageRegular.self, value: &value)
        if let value = value {
          self = .regular(value)
        }
      case 2:
        var value: Orderer_KafkaMessageTimeToCut?
        try setter.decodeSingularMessageField(fieldType: Orderer_KafkaMessageTimeToCut.self, value: &value)
        if let value = value {
          self = .timeToCut(value)
        }
      case 3:
        var value: Orderer_KafkaMessageConnect?
        try setter.decodeSingularMessageField(fieldType: Orderer_KafkaMessageConnect.self, value: &value)
        if let value = value {
          self = .connect(value)
        }
      default:
        self = .None
      }
    }

    public func traverse(visitor: SwiftProtobuf.Visitor, start: Int, end: Int) throws {
      switch self {
      case .regular(let v):
        if start <= 1 && 1 < end {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
      case .timeToCut(let v):
        if start <= 2 && 2 < end {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }
      case .connect(let v):
        if start <= 3 && 3 < end {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        }
      case .None:
        break
      }
    }
  }

  var regular: Orderer_KafkaMessageRegular {
    get {
      if case .regular(let v) = _storage._type {
        return v
      }
      return Orderer_KafkaMessageRegular()
    }
    set {
      _uniqueStorage()._type = .regular(newValue)
    }
  }

  var timeToCut: Orderer_KafkaMessageTimeToCut {
    get {
      if case .timeToCut(let v) = _storage._type {
        return v
      }
      return Orderer_KafkaMessageTimeToCut()
    }
    set {
      _uniqueStorage()._type = .timeToCut(newValue)
    }
  }

  var connect: Orderer_KafkaMessageConnect {
    get {
      if case .connect(let v) = _storage._type {
        return v
      }
      return Orderer_KafkaMessageConnect()
    }
    set {
      _uniqueStorage()._type = .connect(newValue)
    }
  }

  public var type: OneOf_Type {
    get {return _storage._type}
    set {
      _uniqueStorage()._type = newValue
    }
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Orderer_KafkaMessage) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   KafkaMessageRegular wraps a marshalled envelope.
struct Orderer_KafkaMessageRegular: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Orderer_KafkaMessageRegular"}
  public var protoMessageName: String {return "KafkaMessageRegular"}
  public var protoPackageName: String {return "orderer"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "payload", swift: "payload"),
  ]


  var payload: Data = Data()

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &payload)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if payload != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: payload, fieldNumber: 1)
    }
  }

  public func _protoc_generated_isEqualTo(other: Orderer_KafkaMessageRegular) -> Bool {
    if payload != other.payload {return false}
    return true
  }
}

///   KafkaMessageTimeToCut is used to signal to the orderers
///   that it is time to cut block <block_number>.
struct Orderer_KafkaMessageTimeToCut: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Orderer_KafkaMessageTimeToCut"}
  public var protoMessageName: String {return "KafkaMessageTimeToCut"}
  public var protoPackageName: String {return "orderer"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .unique(proto: "block_number", json: "blockNumber", swift: "blockNumber"),
  ]


  var blockNumber: UInt64 = 0

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufUInt64.self, value: &blockNumber)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if blockNumber != 0 {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufUInt64.self, value: blockNumber, fieldNumber: 1)
    }
  }

  public func _protoc_generated_isEqualTo(other: Orderer_KafkaMessageTimeToCut) -> Bool {
    if blockNumber != other.blockNumber {return false}
    return true
  }
}

///   KafkaMessageConnect is posted by an orderer upon booting up.
///   It is used to prevent the panic that would be caused if we
///   were to consume an empty partition. It is ignored by all
///   orderers when processing the partition.
struct Orderer_KafkaMessageConnect: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Orderer_KafkaMessageConnect"}
  public var protoMessageName: String {return "KafkaMessageConnect"}
  public var protoPackageName: String {return "orderer"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "payload", swift: "payload"),
  ]


  var payload: Data = Data()

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &payload)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if payload != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: payload, fieldNumber: 1)
    }
  }

  public func _protoc_generated_isEqualTo(other: Orderer_KafkaMessageConnect) -> Bool {
    if payload != other.payload {return false}
    return true
  }
}

///   LastOffsetPersisted is the encoded value for the Metadata message
///   which is encoded in the ORDERER block metadata index for the case
///   of the Kafka-based orderer.
struct Orderer_KafkaMetadata: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Orderer_KafkaMetadata"}
  public var protoMessageName: String {return "KafkaMetadata"}
  public var protoPackageName: String {return "orderer"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .unique(proto: "last_offset_persisted", json: "lastOffsetPersisted", swift: "lastOffsetPersisted"),
  ]


  var lastOffsetPersisted: Int64 = 0

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt64.self, value: &lastOffsetPersisted)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if lastOffsetPersisted != 0 {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt64.self, value: lastOffsetPersisted, fieldNumber: 1)
    }
  }

  public func _protoc_generated_isEqualTo(other: Orderer_KafkaMetadata) -> Bool {
    if lastOffsetPersisted != other.lastOffsetPersisted {return false}
    return true
  }
}

/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: common/common.proto
 *
 */

// 
// Copyright IBM Corp. 2016 All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf


///   These status codes are intended to resemble selected HTTP status codes
enum Common_Status: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case success // = 200
  case badRequest // = 400
  case forbidden // = 403
  case notFound // = 404
  case requestEntityTooLarge // = 413
  case internalServerError // = 500
  case serviceUnavailable // = 503
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 200: self = .success
    case 400: self = .badRequest
    case 403: self = .forbidden
    case 404: self = .notFound
    case 413: self = .requestEntityTooLarge
    case 500: self = .internalServerError
    case 503: self = .serviceUnavailable
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  init?(name: String) {
    switch name {
    case "unknown": self = .unknown
    case "success": self = .success
    case "badRequest": self = .badRequest
    case "forbidden": self = .forbidden
    case "notFound": self = .notFound
    case "requestEntityTooLarge": self = .requestEntityTooLarge
    case "internalServerError": self = .internalServerError
    case "serviceUnavailable": self = .serviceUnavailable
    default: return nil
    }
  }

  init?(jsonName: String) {
    switch jsonName {
    case "UNKNOWN": self = .unknown
    case "SUCCESS": self = .success
    case "BAD_REQUEST": self = .badRequest
    case "FORBIDDEN": self = .forbidden
    case "NOT_FOUND": self = .notFound
    case "REQUEST_ENTITY_TOO_LARGE": self = .requestEntityTooLarge
    case "INTERNAL_SERVER_ERROR": self = .internalServerError
    case "SERVICE_UNAVAILABLE": self = .serviceUnavailable
    default: return nil
    }
  }

  init?(protoName: String) {
    switch protoName {
    case "UNKNOWN": self = .unknown
    case "SUCCESS": self = .success
    case "BAD_REQUEST": self = .badRequest
    case "FORBIDDEN": self = .forbidden
    case "NOT_FOUND": self = .notFound
    case "REQUEST_ENTITY_TOO_LARGE": self = .requestEntityTooLarge
    case "INTERNAL_SERVER_ERROR": self = .internalServerError
    case "SERVICE_UNAVAILABLE": self = .serviceUnavailable
    default: return nil
    }
  }

  var rawValue: Int {
    get {
      switch self {
      case .unknown: return 0
      case .success: return 200
      case .badRequest: return 400
      case .forbidden: return 403
      case .notFound: return 404
      case .requestEntityTooLarge: return 413
      case .internalServerError: return 500
      case .serviceUnavailable: return 503
      case .UNRECOGNIZED(let i): return i
      }
    }
  }

  var json: String {
    get {
      switch self {
      case .unknown: return "\"UNKNOWN\""
      case .success: return "\"SUCCESS\""
      case .badRequest: return "\"BAD_REQUEST\""
      case .forbidden: return "\"FORBIDDEN\""
      case .notFound: return "\"NOT_FOUND\""
      case .requestEntityTooLarge: return "\"REQUEST_ENTITY_TOO_LARGE\""
      case .internalServerError: return "\"INTERNAL_SERVER_ERROR\""
      case .serviceUnavailable: return "\"SERVICE_UNAVAILABLE\""
      case .UNRECOGNIZED(let i): return String(i)
      }
    }
  }

  var hashValue: Int { return rawValue }

  var debugDescription: String {
    get {
      switch self {
      case .unknown: return ".unknown"
      case .success: return ".success"
      case .badRequest: return ".badRequest"
      case .forbidden: return ".forbidden"
      case .notFound: return ".notFound"
      case .requestEntityTooLarge: return ".requestEntityTooLarge"
      case .internalServerError: return ".internalServerError"
      case .serviceUnavailable: return ".serviceUnavailable"
      case .UNRECOGNIZED(let v): return ".UNRECOGNIZED(\(v))"
      }
    }
  }

}

enum Common_HeaderType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///   Used for messages which are signed but opaque
  case message // = 0

  ///   Used for messages which express the channel config
  case config // = 1

  ///   Used for transactions which update the channel config
  case configUpdate // = 2

  ///   Used by the SDK to submit endorser based transactions
  case endorserTransaction // = 3

  ///   Used internally by the orderer for management
  case ordererTransaction // = 4

  ///   Used as the type for Envelope messages submitted to instruct the Deliver API to seek
  case deliverSeekInfo // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .message
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .message
    case 1: self = .config
    case 2: self = .configUpdate
    case 3: self = .endorserTransaction
    case 4: self = .ordererTransaction
    case 5: self = .deliverSeekInfo
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  init?(name: String) {
    switch name {
    case "message": self = .message
    case "config": self = .config
    case "configUpdate": self = .configUpdate
    case "endorserTransaction": self = .endorserTransaction
    case "ordererTransaction": self = .ordererTransaction
    case "deliverSeekInfo": self = .deliverSeekInfo
    default: return nil
    }
  }

  init?(jsonName: String) {
    switch jsonName {
    case "MESSAGE": self = .message
    case "CONFIG": self = .config
    case "CONFIG_UPDATE": self = .configUpdate
    case "ENDORSER_TRANSACTION": self = .endorserTransaction
    case "ORDERER_TRANSACTION": self = .ordererTransaction
    case "DELIVER_SEEK_INFO": self = .deliverSeekInfo
    default: return nil
    }
  }

  init?(protoName: String) {
    switch protoName {
    case "MESSAGE": self = .message
    case "CONFIG": self = .config
    case "CONFIG_UPDATE": self = .configUpdate
    case "ENDORSER_TRANSACTION": self = .endorserTransaction
    case "ORDERER_TRANSACTION": self = .ordererTransaction
    case "DELIVER_SEEK_INFO": self = .deliverSeekInfo
    default: return nil
    }
  }

  var rawValue: Int {
    get {
      switch self {
      case .message: return 0
      case .config: return 1
      case .configUpdate: return 2
      case .endorserTransaction: return 3
      case .ordererTransaction: return 4
      case .deliverSeekInfo: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }
  }

  var json: String {
    get {
      switch self {
      case .message: return "\"MESSAGE\""
      case .config: return "\"CONFIG\""
      case .configUpdate: return "\"CONFIG_UPDATE\""
      case .endorserTransaction: return "\"ENDORSER_TRANSACTION\""
      case .ordererTransaction: return "\"ORDERER_TRANSACTION\""
      case .deliverSeekInfo: return "\"DELIVER_SEEK_INFO\""
      case .UNRECOGNIZED(let i): return String(i)
      }
    }
  }

  var hashValue: Int { return rawValue }

  var debugDescription: String {
    get {
      switch self {
      case .message: return ".message"
      case .config: return ".config"
      case .configUpdate: return ".configUpdate"
      case .endorserTransaction: return ".endorserTransaction"
      case .ordererTransaction: return ".ordererTransaction"
      case .deliverSeekInfo: return ".deliverSeekInfo"
      case .UNRECOGNIZED(let v): return ".UNRECOGNIZED(\(v))"
      }
    }
  }

}

///   This enum enlists indexes of the block metadata array
enum Common_BlockMetadataIndex: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///   Block metadata array position for block signatures
  case signatures // = 0

  ///   Block metadata array poistion to store last configuration block sequence number
  case lastConfig // = 1

  ///   Block metadata array poistion to store serialized bit array filter of invalid transactions
  case transactionsFilter // = 2

  ///   Block metadata array position to store operational metadata for orderers
  case orderer // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .signatures
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .signatures
    case 1: self = .lastConfig
    case 2: self = .transactionsFilter
    case 3: self = .orderer
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  init?(name: String) {
    switch name {
    case "signatures": self = .signatures
    case "lastConfig": self = .lastConfig
    case "transactionsFilter": self = .transactionsFilter
    case "orderer": self = .orderer
    default: return nil
    }
  }

  init?(jsonName: String) {
    switch jsonName {
    case "SIGNATURES": self = .signatures
    case "LAST_CONFIG": self = .lastConfig
    case "TRANSACTIONS_FILTER": self = .transactionsFilter
    case "ORDERER": self = .orderer
    default: return nil
    }
  }

  init?(protoName: String) {
    switch protoName {
    case "SIGNATURES": self = .signatures
    case "LAST_CONFIG": self = .lastConfig
    case "TRANSACTIONS_FILTER": self = .transactionsFilter
    case "ORDERER": self = .orderer
    default: return nil
    }
  }

  var rawValue: Int {
    get {
      switch self {
      case .signatures: return 0
      case .lastConfig: return 1
      case .transactionsFilter: return 2
      case .orderer: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }
  }

  var json: String {
    get {
      switch self {
      case .signatures: return "\"SIGNATURES\""
      case .lastConfig: return "\"LAST_CONFIG\""
      case .transactionsFilter: return "\"TRANSACTIONS_FILTER\""
      case .orderer: return "\"ORDERER\""
      case .UNRECOGNIZED(let i): return String(i)
      }
    }
  }

  var hashValue: Int { return rawValue }

  var debugDescription: String {
    get {
      switch self {
      case .signatures: return ".signatures"
      case .lastConfig: return ".lastConfig"
      case .transactionsFilter: return ".transactionsFilter"
      case .orderer: return ".orderer"
      case .UNRECOGNIZED(let v): return ".UNRECOGNIZED(\(v))"
      }
    }
  }

}

///   LastConfig is the encoded value for the Metadata message which is encoded in the LAST_CONFIGURATION block metadata index
struct Common_LastConfig: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_LastConfig"}
  public var protoMessageName: String {return "LastConfig"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "index", swift: "index"),
  ]


  var index: UInt64 = 0

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufUInt64.self, value: &index)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if index != 0 {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufUInt64.self, value: index, fieldNumber: 1)
    }
  }

  public func _protoc_generated_isEqualTo(other: Common_LastConfig) -> Bool {
    if index != other.index {return false}
    return true
  }
}

///   Metadata is a common structure to be used to encode block metadata
struct Common_Metadata: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_Metadata"}
  public var protoMessageName: String {return "Metadata"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "value", swift: "value"),
    2: .same(proto: "signatures", swift: "signatures"),
  ]


  var value: Data = Data()

  var signatures: [Common_MetadataSignature] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &value)
    case 2: try setter.decodeRepeatedMessageField(fieldType: Common_MetadataSignature.self, value: &signatures)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if value != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: value, fieldNumber: 1)
    }
    if !signatures.isEmpty {
      try visitor.visitRepeatedMessageField(value: signatures, fieldNumber: 2)
    }
  }

  public func _protoc_generated_isEqualTo(other: Common_Metadata) -> Bool {
    if value != other.value {return false}
    if signatures != other.signatures {return false}
    return true
  }
}

struct Common_MetadataSignature: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_MetadataSignature"}
  public var protoMessageName: String {return "MetadataSignature"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .unique(proto: "signature_header", json: "signatureHeader", swift: "signatureHeader"),
    2: .same(proto: "signature", swift: "signature"),
  ]


  ///   An encoded SignatureHeader
  var signatureHeader: Data = Data()

  ///   The signature over the concatenation of the Metadata value bytes, signatureHeader, and block header
  var signature: Data = Data()

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &signatureHeader)
    case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &signature)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if signatureHeader != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: signatureHeader, fieldNumber: 1)
    }
    if signature != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: signature, fieldNumber: 2)
    }
  }

  public func _protoc_generated_isEqualTo(other: Common_MetadataSignature) -> Bool {
    if signatureHeader != other.signatureHeader {return false}
    if signature != other.signature {return false}
    return true
  }
}

struct Common_Header: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_Header"}
  public var protoMessageName: String {return "Header"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .unique(proto: "channel_header", json: "channelHeader", swift: "channelHeader"),
    2: .unique(proto: "signature_header", json: "signatureHeader", swift: "signatureHeader"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Common_Header
    var _channelHeader: Common_ChannelHeader? = nil
    var _signatureHeader: Common_SignatureHeader? = nil

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularMessageField(fieldType: Common_ChannelHeader.self, value: &_channelHeader)
      case 2: try setter.decodeSingularMessageField(fieldType: Common_SignatureHeader.self, value: &_signatureHeader)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if let v = _channelHeader {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _signatureHeader {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _channelHeader != other._channelHeader {return false}
      if _signatureHeader != other._signatureHeader {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._channelHeader = _channelHeader
      clone._signatureHeader = _signatureHeader
      return clone
    }
  }

  private var _storage = _StorageClass()


  var channelHeader: Common_ChannelHeader {
    get {return _storage._channelHeader ?? Common_ChannelHeader()}
    set {_uniqueStorage()._channelHeader = newValue}
  }
  public var hasChannelHeader: Bool {
    return _storage._channelHeader != nil
  }
  public mutating func clearChannelHeader() {
    return _storage._channelHeader = nil
  }

  var signatureHeader: Common_SignatureHeader {
    get {return _storage._signatureHeader ?? Common_SignatureHeader()}
    set {_uniqueStorage()._signatureHeader = newValue}
  }
  public var hasSignatureHeader: Bool {
    return _storage._signatureHeader != nil
  }
  public mutating func clearSignatureHeader() {
    return _storage._signatureHeader = nil
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Common_Header) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Header is a generic replay prevention and identity message to include in a signed payload
struct Common_ChannelHeader: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_ChannelHeader"}
  public var protoMessageName: String {return "ChannelHeader"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "type", swift: "type"),
    2: .same(proto: "version", swift: "version"),
    3: .same(proto: "timestamp", swift: "timestamp"),
    4: .unique(proto: "channel_id", json: "channelId", swift: "channelId"),
    5: .unique(proto: "tx_id", json: "txId", swift: "txId"),
    6: .same(proto: "epoch", swift: "epoch"),
    7: .same(proto: "extension", swift: "extension_p"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Common_ChannelHeader
    var _type: Int32 = 0
    var _version: Int32 = 0
    var _timestamp: Google_Protobuf_Timestamp? = nil
    var _channelId: String = ""
    var _txId: String = ""
    var _epoch: UInt64 = 0
    var _extension_p: Data = Data()

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &_type)
      case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &_version)
      case 3: try setter.decodeSingularMessageField(fieldType: Google_Protobuf_Timestamp.self, value: &_timestamp)
      case 4: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_channelId)
      case 5: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_txId)
      case 6: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufUInt64.self, value: &_epoch)
      case 7: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &_extension_p)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if _type != 0 {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: _type, fieldNumber: 1)
      }
      if _version != 0 {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: _version, fieldNumber: 2)
      }
      if let v = _timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _channelId != "" {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: _channelId, fieldNumber: 4)
      }
      if _txId != "" {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: _txId, fieldNumber: 5)
      }
      if _epoch != 0 {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufUInt64.self, value: _epoch, fieldNumber: 6)
      }
      if _extension_p != Data() {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: _extension_p, fieldNumber: 7)
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _type != other._type {return false}
      if _version != other._version {return false}
      if _timestamp != other._timestamp {return false}
      if _channelId != other._channelId {return false}
      if _txId != other._txId {return false}
      if _epoch != other._epoch {return false}
      if _extension_p != other._extension_p {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._type = _type
      clone._version = _version
      clone._timestamp = _timestamp
      clone._channelId = _channelId
      clone._txId = _txId
      clone._epoch = _epoch
      clone._extension_p = _extension_p
      return clone
    }
  }

  private var _storage = _StorageClass()


  ///   Header types 0-10000 are reserved and defined by HeaderType
  var type: Int32 {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  ///   Version indicates message protocol version
  var version: Int32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  ///   Timestamp is the local time when the message was created
  ///   by the sender
  var timestamp: Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  public var hasTimestamp: Bool {
    return _storage._timestamp != nil
  }
  public mutating func clearTimestamp() {
    return _storage._timestamp = nil
  }

  ///   Identifier of the channel this message is bound for
  var channelId: String {
    get {return _storage._channelId}
    set {_uniqueStorage()._channelId = newValue}
  }

  ///   An unique identifier that is used end-to-end.
  ///    -  set by higher layers such as end user or SDK
  ///    -  passed to the endorser (which will check for uniqueness)
  ///    -  as the header is passed along unchanged, it will be
  ///       be retrieved by the committer (uniqueness check here as well)
  ///    -  to be stored in the ledger
  var txId: String {
    get {return _storage._txId}
    set {_uniqueStorage()._txId = newValue}
  }

  ///   The epoch in which this header was generated, where epoch is defined based on block height
  ///   Epoch in which the response has been generated. This field identifies a
  ///   logical window of time. A proposal response is accepted by a peer only if
  ///   two conditions hold:
  ///   1. the epoch specified in the message is the current epoch
  ///   2. this message has been only seen once during this epoch (i.e. it hasn't
  ///      been replayed)
  var epoch: UInt64 {
    get {return _storage._epoch}
    set {_uniqueStorage()._epoch = newValue}
  }

  ///   Extension that may be attached based on the header type
  var extension_p: Data {
    get {return _storage._extension_p}
    set {_uniqueStorage()._extension_p = newValue}
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Common_ChannelHeader) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

struct Common_SignatureHeader: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_SignatureHeader"}
  public var protoMessageName: String {return "SignatureHeader"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "creator", swift: "creator"),
    2: .same(proto: "nonce", swift: "nonce"),
  ]


  ///   Creator of the message, specified as a certificate chain
  var creator: Data = Data()

  ///   Arbitrary number that may only be used once. Can be used to detect replay attacks.
  var nonce: Data = Data()

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &creator)
    case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &nonce)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if creator != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: creator, fieldNumber: 1)
    }
    if nonce != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: nonce, fieldNumber: 2)
    }
  }

  public func _protoc_generated_isEqualTo(other: Common_SignatureHeader) -> Bool {
    if creator != other.creator {return false}
    if nonce != other.nonce {return false}
    return true
  }
}

///   Payload is the message contents (and header to allow for signing)
struct Common_Payload: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_Payload"}
  public var protoMessageName: String {return "Payload"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "header", swift: "header"),
    2: .same(proto: "data", swift: "data"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Common_Payload
    var _header: Common_Header? = nil
    var _data: Data = Data()

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularMessageField(fieldType: Common_Header.self, value: &_header)
      case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &_data)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if let v = _header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _data != Data() {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: _data, fieldNumber: 2)
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _header != other._header {return false}
      if _data != other._data {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._header = _header
      clone._data = _data
      return clone
    }
  }

  private var _storage = _StorageClass()


  ///   Header is included to provide identity and prevent replay
  var header: Common_Header {
    get {return _storage._header ?? Common_Header()}
    set {_uniqueStorage()._header = newValue}
  }
  public var hasHeader: Bool {
    return _storage._header != nil
  }
  public mutating func clearHeader() {
    return _storage._header = nil
  }

  ///   Data, the encoding of which is defined by the type in the header
  var data: Data {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Common_Payload) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Envelope wraps a Payload with a signature so that the message may be authenticated
struct Common_Envelope: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_Envelope"}
  public var protoMessageName: String {return "Envelope"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "payload", swift: "payload"),
    2: .same(proto: "signature", swift: "signature"),
  ]


  ///   A marshaled Payload
  var payload: Data = Data()

  ///   A signature by the creator specified in the Payload header
  var signature: Data = Data()

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &payload)
    case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &signature)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if payload != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: payload, fieldNumber: 1)
    }
    if signature != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: signature, fieldNumber: 2)
    }
  }

  public func _protoc_generated_isEqualTo(other: Common_Envelope) -> Bool {
    if payload != other.payload {return false}
    if signature != other.signature {return false}
    return true
  }
}

///   This is finalized block structure to be shared among the orderer and peer
///   Note that the BlockHeader chains to the previous BlockHeader, and the BlockData hash is embedded
///   in the BlockHeader.  This makes it natural and obvious that the Data is included in the hash, but
///   the Metadata is not.
struct Common_Block: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_Block"}
  public var protoMessageName: String {return "Block"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "header", swift: "header"),
    2: .same(proto: "data", swift: "data"),
    3: .same(proto: "metadata", swift: "metadata"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Common_Block
    var _header: Common_BlockHeader? = nil
    var _data: Common_BlockData? = nil
    var _metadata: Common_BlockMetadata? = nil

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularMessageField(fieldType: Common_BlockHeader.self, value: &_header)
      case 2: try setter.decodeSingularMessageField(fieldType: Common_BlockData.self, value: &_data)
      case 3: try setter.decodeSingularMessageField(fieldType: Common_BlockMetadata.self, value: &_metadata)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if let v = _header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _header != other._header {return false}
      if _data != other._data {return false}
      if _metadata != other._metadata {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._header = _header
      clone._data = _data
      clone._metadata = _metadata
      return clone
    }
  }

  private var _storage = _StorageClass()


  var header: Common_BlockHeader {
    get {return _storage._header ?? Common_BlockHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  public var hasHeader: Bool {
    return _storage._header != nil
  }
  public mutating func clearHeader() {
    return _storage._header = nil
  }

  var data: Common_BlockData {
    get {return _storage._data ?? Common_BlockData()}
    set {_uniqueStorage()._data = newValue}
  }
  public var hasData: Bool {
    return _storage._data != nil
  }
  public mutating func clearData() {
    return _storage._data = nil
  }

  var metadata: Common_BlockMetadata {
    get {return _storage._metadata ?? Common_BlockMetadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  public var hasMetadata: Bool {
    return _storage._metadata != nil
  }
  public mutating func clearMetadata() {
    return _storage._metadata = nil
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Common_Block) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   BlockHeader is the element of the block which forms the block chain
///   The block header is hashed using the configured chain hashing algorithm
///   over the ASN.1 encoding of the BlockHeader
struct Common_BlockHeader: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_BlockHeader"}
  public var protoMessageName: String {return "BlockHeader"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "number", swift: "number"),
    2: .unique(proto: "previous_hash", json: "previousHash", swift: "previousHash"),
    3: .unique(proto: "data_hash", json: "dataHash", swift: "dataHash"),
  ]


  ///   The position in the blockchain
  var number: UInt64 = 0

  ///   The hash of the previous block header
  var previousHash: Data = Data()

  ///   The hash of the BlockData, by MerkleTree
  var dataHash: Data = Data()

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufUInt64.self, value: &number)
    case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &previousHash)
    case 3: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &dataHash)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if number != 0 {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufUInt64.self, value: number, fieldNumber: 1)
    }
    if previousHash != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: previousHash, fieldNumber: 2)
    }
    if dataHash != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: dataHash, fieldNumber: 3)
    }
  }

  public func _protoc_generated_isEqualTo(other: Common_BlockHeader) -> Bool {
    if number != other.number {return false}
    if previousHash != other.previousHash {return false}
    if dataHash != other.dataHash {return false}
    return true
  }
}

struct Common_BlockData: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_BlockData"}
  public var protoMessageName: String {return "BlockData"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "data", swift: "data"),
  ]


  var data: [Data] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeRepeatedField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &data)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if !data.isEmpty {
      try visitor.visitRepeatedField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: data, fieldNumber: 1)
    }
  }

  public func _protoc_generated_isEqualTo(other: Common_BlockData) -> Bool {
    if data != other.data {return false}
    return true
  }
}

struct Common_BlockMetadata: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_BlockMetadata"}
  public var protoMessageName: String {return "BlockMetadata"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "metadata", swift: "metadata"),
  ]


  var metadata: [Data] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeRepeatedField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &metadata)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if !metadata.isEmpty {
      try visitor.visitRepeatedField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: metadata, fieldNumber: 1)
    }
  }

  public func _protoc_generated_isEqualTo(other: Common_BlockMetadata) -> Bool {
    if metadata != other.metadata {return false}
    return true
  }
}

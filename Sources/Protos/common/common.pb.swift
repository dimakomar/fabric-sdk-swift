/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: common/common.proto
 *
 */

// 
// Copyright IBM Corp. 2016 All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _1: SwiftProtobuf.ProtobufAPIVersion_1 {}
  typealias Version = _1
}

///   These status codes are intended to resemble selected HTTP status codes
enum Common_Status: SwiftProtobuf.Enum, SwiftProtobuf._ProtoNameProviding {
  typealias RawValue = Int
  case unknown // = 0
  case success // = 200
  case badRequest // = 400
  case forbidden // = 403
  case notFound // = 404
  case requestEntityTooLarge // = 413
  case internalServerError // = 500
  case serviceUnavailable // = 503
  case UNRECOGNIZED(Int)

  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    200: .same(proto: "SUCCESS"),
    400: .same(proto: "BAD_REQUEST"),
    403: .same(proto: "FORBIDDEN"),
    404: .same(proto: "NOT_FOUND"),
    413: .same(proto: "REQUEST_ENTITY_TOO_LARGE"),
    500: .same(proto: "INTERNAL_SERVER_ERROR"),
    503: .same(proto: "SERVICE_UNAVAILABLE"),
  ]

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 200: self = .success
    case 400: self = .badRequest
    case 403: self = .forbidden
    case 404: self = .notFound
    case 413: self = .requestEntityTooLarge
    case 500: self = .internalServerError
    case 503: self = .serviceUnavailable
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .success: return 200
    case .badRequest: return 400
    case .forbidden: return 403
    case .notFound: return 404
    case .requestEntityTooLarge: return 413
    case .internalServerError: return 500
    case .serviceUnavailable: return 503
    case .UNRECOGNIZED(let i): return i
    }
  }

}

enum Common_HeaderType: SwiftProtobuf.Enum, SwiftProtobuf._ProtoNameProviding {
  typealias RawValue = Int

  ///   Used for messages which are signed but opaque
  case message // = 0

  ///   Used for messages which express the channel config
  case config // = 1

  ///   Used for transactions which update the channel config
  case configUpdate // = 2

  ///   Used by the SDK to submit endorser based transactions
  case endorserTransaction // = 3

  ///   Used internally by the orderer for management
  case ordererTransaction // = 4

  ///   Used as the type for Envelope messages submitted to instruct the Deliver API to seek
  case deliverSeekInfo // = 5
  case UNRECOGNIZED(Int)

  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MESSAGE"),
    1: .same(proto: "CONFIG"),
    2: .same(proto: "CONFIG_UPDATE"),
    3: .same(proto: "ENDORSER_TRANSACTION"),
    4: .same(proto: "ORDERER_TRANSACTION"),
    5: .same(proto: "DELIVER_SEEK_INFO"),
  ]

  init() {
    self = .message
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .message
    case 1: self = .config
    case 2: self = .configUpdate
    case 3: self = .endorserTransaction
    case 4: self = .ordererTransaction
    case 5: self = .deliverSeekInfo
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .message: return 0
    case .config: return 1
    case .configUpdate: return 2
    case .endorserTransaction: return 3
    case .ordererTransaction: return 4
    case .deliverSeekInfo: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

///   This enum enlists indexes of the block metadata array
enum Common_BlockMetadataIndex: SwiftProtobuf.Enum, SwiftProtobuf._ProtoNameProviding {
  typealias RawValue = Int

  ///   Block metadata array position for block signatures
  case signatures // = 0

  ///   Block metadata array poistion to store last configuration block sequence number
  case lastConfig // = 1

  ///   Block metadata array poistion to store serialized bit array filter of invalid transactions
  case transactionsFilter // = 2

  ///   Block metadata array position to store operational metadata for orderers
  case orderer // = 3
  case UNRECOGNIZED(Int)

  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SIGNATURES"),
    1: .same(proto: "LAST_CONFIG"),
    2: .same(proto: "TRANSACTIONS_FILTER"),
    3: .same(proto: "ORDERER"),
  ]

  init() {
    self = .signatures
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .signatures
    case 1: self = .lastConfig
    case 2: self = .transactionsFilter
    case 3: self = .orderer
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .signatures: return 0
    case .lastConfig: return 1
    case .transactionsFilter: return 2
    case .orderer: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

///   LastConfig is the encoded value for the Metadata message which is encoded in the LAST_CONFIGURATION block metadata index
struct Common_LastConfig: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LastConfig"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
  ]

  var index: UInt64 = 0

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularUInt64Field(value: &index)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if index != 0 {
      try visitor.visitSingularUInt64Field(value: index, fieldNumber: 1)
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_LastConfig) -> Bool {
    if index != other.index {return false}
    return true
  }
}

///   Metadata is a common structure to be used to encode block metadata
struct Common_Metadata: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Metadata"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "signatures"),
  ]

  var value: Data = Data()

  var signatures: [Common_MetadataSignature] = []

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularBytesField(value: &value)
    case 2: try decoder.decodeRepeatedMessageField(value: &signatures)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !value.isEmpty {
      try visitor.visitSingularBytesField(value: value, fieldNumber: 1)
    }
    if !signatures.isEmpty {
      try visitor.visitRepeatedMessageField(value: signatures, fieldNumber: 2)
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_Metadata) -> Bool {
    if value != other.value {return false}
    if signatures != other.signatures {return false}
    return true
  }
}

struct Common_MetadataSignature: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MetadataSignature"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "signature_header", json: "signatureHeader"),
    2: .same(proto: "signature"),
  ]

  ///   An encoded SignatureHeader
  var signatureHeader: Data = Data()

  ///   The signature over the concatenation of the Metadata value bytes, signatureHeader, and block header
  var signature: Data = Data()

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularBytesField(value: &signatureHeader)
    case 2: try decoder.decodeSingularBytesField(value: &signature)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !signatureHeader.isEmpty {
      try visitor.visitSingularBytesField(value: signatureHeader, fieldNumber: 1)
    }
    if !signature.isEmpty {
      try visitor.visitSingularBytesField(value: signature, fieldNumber: 2)
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_MetadataSignature) -> Bool {
    if signatureHeader != other.signatureHeader {return false}
    if signature != other.signature {return false}
    return true
  }
}

struct Common_Header: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Header"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "channel_header", json: "channelHeader"),
    2: .unique(proto: "signature_header", json: "signatureHeader"),
  ]

  var channelHeader: Data = Data()

  var signatureHeader: Data = Data()

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularBytesField(value: &channelHeader)
    case 2: try decoder.decodeSingularBytesField(value: &signatureHeader)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !channelHeader.isEmpty {
      try visitor.visitSingularBytesField(value: channelHeader, fieldNumber: 1)
    }
    if !signatureHeader.isEmpty {
      try visitor.visitSingularBytesField(value: signatureHeader, fieldNumber: 2)
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_Header) -> Bool {
    if channelHeader != other.channelHeader {return false}
    if signatureHeader != other.signatureHeader {return false}
    return true
  }
}

///   Header is a generic replay prevention and identity message to include in a signed payload
struct Common_ChannelHeader: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChannelHeader"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "version"),
    3: .same(proto: "timestamp"),
    4: .unique(proto: "channel_id", json: "channelId"),
    5: .unique(proto: "tx_id", json: "txId"),
    6: .same(proto: "epoch"),
    7: .same(proto: "extension"),
  ]

  private class _StorageClass {
    var _type: Int32 = 0
    var _version: Int32 = 0
    var _timestamp: Google_Protobuf_Timestamp? = nil
    var _channelId: String = ""
    var _txId: String = ""
    var _epoch: UInt64 = 0
    var _extension_p: Data = Data()

    init() {}

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._type = _type
      clone._version = _version
      clone._timestamp = _timestamp
      clone._channelId = _channelId
      clone._txId = _txId
      clone._epoch = _epoch
      clone._extension_p = _extension_p
      return clone
    }
  }

  private var _storage = _StorageClass()

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }

  ///   Header types 0-10000 are reserved and defined by HeaderType
  var type: Int32 {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  ///   Version indicates message protocol version
  var version: Int32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  ///   Timestamp is the local time when the message was created
  ///   by the sender
  var timestamp: Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  var hasTimestamp: Bool {
    return _storage._timestamp != nil
  }
  mutating func clearTimestamp() {
    return _storage._timestamp = nil
  }

  ///   Identifier of the channel this message is bound for
  var channelId: String {
    get {return _storage._channelId}
    set {_uniqueStorage()._channelId = newValue}
  }

  ///   An unique identifier that is used end-to-end.
  ///    -  set by higher layers such as end user or SDK
  ///    -  passed to the endorser (which will check for uniqueness)
  ///    -  as the header is passed along unchanged, it will be
  ///       be retrieved by the committer (uniqueness check here as well)
  ///    -  to be stored in the ledger
  var txId: String {
    get {return _storage._txId}
    set {_uniqueStorage()._txId = newValue}
  }

  ///   The epoch in which this header was generated, where epoch is defined based on block height
  ///   Epoch in which the response has been generated. This field identifies a
  ///   logical window of time. A proposal response is accepted by a peer only if
  ///   two conditions hold:
  ///   1. the epoch specified in the message is the current epoch
  ///   2. this message has been only seen once during this epoch (i.e. it hasn't
  ///      been replayed)
  var epoch: UInt64 {
    get {return _storage._epoch}
    set {_uniqueStorage()._epoch = newValue}
  }

  ///   Extension that may be attached based on the header type
  var extension_p: Data {
    get {return _storage._extension_p}
    set {_uniqueStorage()._extension_p = newValue}
  }

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
      }
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularInt32Field(value: &_storage._type)
    case 2: try decoder.decodeSingularInt32Field(value: &_storage._version)
    case 3: try decoder.decodeSingularMessageField(value: &_storage._timestamp)
    case 4: try decoder.decodeSingularStringField(value: &_storage._channelId)
    case 5: try decoder.decodeSingularStringField(value: &_storage._txId)
    case 6: try decoder.decodeSingularUInt64Field(value: &_storage._epoch)
    case 7: try decoder.decodeSingularBytesField(value: &_storage._extension_p)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != 0 {
        try visitor.visitSingularInt32Field(value: _storage._type, fieldNumber: 1)
      }
      if _storage._version != 0 {
        try visitor.visitSingularInt32Field(value: _storage._version, fieldNumber: 2)
      }
      if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._channelId.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelId, fieldNumber: 4)
      }
      if !_storage._txId.isEmpty {
        try visitor.visitSingularStringField(value: _storage._txId, fieldNumber: 5)
      }
      if _storage._epoch != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._epoch, fieldNumber: 6)
      }
      if !_storage._extension_p.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._extension_p, fieldNumber: 7)
      }
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_ChannelHeader) -> Bool {
    return withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
      if _storage !== other_storage {
        if _storage._type != other_storage._type {return false}
        if _storage._version != other_storage._version {return false}
        if _storage._timestamp != other_storage._timestamp {return false}
        if _storage._channelId != other_storage._channelId {return false}
        if _storage._txId != other_storage._txId {return false}
        if _storage._epoch != other_storage._epoch {return false}
        if _storage._extension_p != other_storage._extension_p {return false}
      }
      return true
    }
  }
}

struct Common_SignatureHeader: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SignatureHeader"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "nonce"),
  ]

  ///   Creator of the message, specified as a certificate chain
  var creator: Data = Data()

  ///   Arbitrary number that may only be used once. Can be used to detect replay attacks.
  var nonce: Data = Data()

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularBytesField(value: &creator)
    case 2: try decoder.decodeSingularBytesField(value: &nonce)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !creator.isEmpty {
      try visitor.visitSingularBytesField(value: creator, fieldNumber: 1)
    }
    if !nonce.isEmpty {
      try visitor.visitSingularBytesField(value: nonce, fieldNumber: 2)
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_SignatureHeader) -> Bool {
    if creator != other.creator {return false}
    if nonce != other.nonce {return false}
    return true
  }
}

///   Payload is the message contents (and header to allow for signing)
struct Common_Payload: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Payload"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "data"),
  ]

  private class _StorageClass {
    var _header: Common_Header? = nil
    var _data: Data = Data()

    init() {}

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._header = _header
      clone._data = _data
      return clone
    }
  }

  private var _storage = _StorageClass()

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }

  ///   Header is included to provide identity and prevent replay
  var header: Common_Header {
    get {return _storage._header ?? Common_Header()}
    set {_uniqueStorage()._header = newValue}
  }
  var hasHeader: Bool {
    return _storage._header != nil
  }
  mutating func clearHeader() {
    return _storage._header = nil
  }

  ///   Data, the encoding of which is defined by the type in the header
  var data: Data {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
      }
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularMessageField(value: &_storage._header)
    case 2: try decoder.decodeSingularBytesField(value: &_storage._data)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._data.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._data, fieldNumber: 2)
      }
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_Payload) -> Bool {
    return withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
      if _storage !== other_storage {
        if _storage._header != other_storage._header {return false}
        if _storage._data != other_storage._data {return false}
      }
      return true
    }
  }
}

///   Envelope wraps a Payload with a signature so that the message may be authenticated
struct Common_Envelope: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Envelope"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
    2: .same(proto: "signature"),
  ]

  ///   A marshaled Payload
  var payload: Data = Data()

  ///   A signature by the creator specified in the Payload header
  var signature: Data = Data()

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularBytesField(value: &payload)
    case 2: try decoder.decodeSingularBytesField(value: &signature)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !payload.isEmpty {
      try visitor.visitSingularBytesField(value: payload, fieldNumber: 1)
    }
    if !signature.isEmpty {
      try visitor.visitSingularBytesField(value: signature, fieldNumber: 2)
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_Envelope) -> Bool {
    if payload != other.payload {return false}
    if signature != other.signature {return false}
    return true
  }
}

///   This is finalized block structure to be shared among the orderer and peer
///   Note that the BlockHeader chains to the previous BlockHeader, and the BlockData hash is embedded
///   in the BlockHeader.  This makes it natural and obvious that the Data is included in the hash, but
///   the Metadata is not.
struct Common_Block: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Block"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "data"),
    3: .same(proto: "metadata"),
  ]

  private class _StorageClass {
    var _header: Common_BlockHeader? = nil
    var _data: Common_BlockData? = nil
    var _metadata: Common_BlockMetadata? = nil

    init() {}

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._header = _header
      clone._data = _data
      clone._metadata = _metadata
      return clone
    }
  }

  private var _storage = _StorageClass()

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }

  var header: Common_BlockHeader {
    get {return _storage._header ?? Common_BlockHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  var hasHeader: Bool {
    return _storage._header != nil
  }
  mutating func clearHeader() {
    return _storage._header = nil
  }

  var data: Common_BlockData {
    get {return _storage._data ?? Common_BlockData()}
    set {_uniqueStorage()._data = newValue}
  }
  var hasData: Bool {
    return _storage._data != nil
  }
  mutating func clearData() {
    return _storage._data = nil
  }

  var metadata: Common_BlockMetadata {
    get {return _storage._metadata ?? Common_BlockMetadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  var hasMetadata: Bool {
    return _storage._metadata != nil
  }
  mutating func clearMetadata() {
    return _storage._metadata = nil
  }

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
      }
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularMessageField(value: &_storage._header)
    case 2: try decoder.decodeSingularMessageField(value: &_storage._data)
    case 3: try decoder.decodeSingularMessageField(value: &_storage._metadata)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_Block) -> Bool {
    return withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
      if _storage !== other_storage {
        if _storage._header != other_storage._header {return false}
        if _storage._data != other_storage._data {return false}
        if _storage._metadata != other_storage._metadata {return false}
      }
      return true
    }
  }
}

///   BlockHeader is the element of the block which forms the block chain
///   The block header is hashed using the configured chain hashing algorithm
///   over the ASN.1 encoding of the BlockHeader
struct Common_BlockHeader: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BlockHeader"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "number"),
    2: .unique(proto: "previous_hash", json: "previousHash"),
    3: .unique(proto: "data_hash", json: "dataHash"),
  ]

  ///   The position in the blockchain
  var number: UInt64 = 0

  ///   The hash of the previous block header
  var previousHash: Data = Data()

  ///   The hash of the BlockData, by MerkleTree
  var dataHash: Data = Data()

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularUInt64Field(value: &number)
    case 2: try decoder.decodeSingularBytesField(value: &previousHash)
    case 3: try decoder.decodeSingularBytesField(value: &dataHash)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if number != 0 {
      try visitor.visitSingularUInt64Field(value: number, fieldNumber: 1)
    }
    if !previousHash.isEmpty {
      try visitor.visitSingularBytesField(value: previousHash, fieldNumber: 2)
    }
    if !dataHash.isEmpty {
      try visitor.visitSingularBytesField(value: dataHash, fieldNumber: 3)
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_BlockHeader) -> Bool {
    if number != other.number {return false}
    if previousHash != other.previousHash {return false}
    if dataHash != other.dataHash {return false}
    return true
  }
}

struct Common_BlockData: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BlockData"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  var data: [Data] = []

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeRepeatedBytesField(value: &data)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !data.isEmpty {
      try visitor.visitRepeatedBytesField(value: data, fieldNumber: 1)
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_BlockData) -> Bool {
    if data != other.data {return false}
    return true
  }
}

struct Common_BlockMetadata: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BlockMetadata"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  var metadata: [Data] = []

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeRepeatedBytesField(value: &metadata)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !metadata.isEmpty {
      try visitor.visitRepeatedBytesField(value: metadata, fieldNumber: 1)
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_BlockMetadata) -> Bool {
    if metadata != other.metadata {return false}
    return true
  }
}

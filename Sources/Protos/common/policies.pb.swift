/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: common/policies.proto
 *
 */

// 
// Copyright IBM Corp. 2017 All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _1: SwiftProtobuf.ProtobufAPIVersion_1 {}
  typealias Version = _1
}

///   Policy expresses a policy which the orderer can evaluate, because there has been some desire expressed to support
///   multiple policy engines, this is typed as a oneof for now
struct Common_Policy: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Policy"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "policy"),
  ]

  ///   For outside implementors, consider the first 1000 types reserved, otherwise one of PolicyType
  var type: Int32 = 0

  var policy: Data = Data()

  enum PolicyType: SwiftProtobuf.Enum, SwiftProtobuf._ProtoNameProviding {
    typealias RawValue = Int

    ///   Reserved to check for proper initialization
    case unknown // = 0
    case signature // = 1
    case msp // = 2
    case implicitMeta // = 3
    case UNRECOGNIZED(Int)

    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
      0: .same(proto: "UNKNOWN"),
      1: .same(proto: "SIGNATURE"),
      2: .same(proto: "MSP"),
      3: .same(proto: "IMPLICIT_META"),
    ]

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .signature
      case 2: self = .msp
      case 3: self = .implicitMeta
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .signature: return 1
      case .msp: return 2
      case .implicitMeta: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularInt32Field(value: &type)
    case 2: try decoder.decodeSingularBytesField(value: &policy)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if type != 0 {
      try visitor.visitSingularInt32Field(value: type, fieldNumber: 1)
    }
    if !policy.isEmpty {
      try visitor.visitSingularBytesField(value: policy, fieldNumber: 2)
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_Policy) -> Bool {
    if type != other.type {return false}
    if policy != other.policy {return false}
    return true
  }
}

///   SignaturePolicyEnvelope wraps a SignaturePolicy and includes a version for future enhancements
struct Common_SignaturePolicyEnvelope: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SignaturePolicyEnvelope"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "policy"),
    3: .same(proto: "identities"),
  ]

  private class _StorageClass {
    var _version: Int32 = 0
    var _policy: Common_SignaturePolicy? = nil
    var _identities: [Common_MSPPrincipal] = []

    init() {}

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._version = _version
      clone._policy = _policy
      clone._identities = _identities
      return clone
    }
  }

  private var _storage = _StorageClass()

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }

  var version: Int32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  var policy: Common_SignaturePolicy {
    get {return _storage._policy ?? Common_SignaturePolicy()}
    set {_uniqueStorage()._policy = newValue}
  }
  var hasPolicy: Bool {
    return _storage._policy != nil
  }
  mutating func clearPolicy() {
    return _storage._policy = nil
  }

  var identities: [Common_MSPPrincipal] {
    get {return _storage._identities}
    set {_uniqueStorage()._identities = newValue}
  }

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
      }
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularInt32Field(value: &_storage._version)
    case 2: try decoder.decodeSingularMessageField(value: &_storage._policy)
    case 3: try decoder.decodeRepeatedMessageField(value: &_storage._identities)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._version != 0 {
        try visitor.visitSingularInt32Field(value: _storage._version, fieldNumber: 1)
      }
      if let v = _storage._policy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._identities.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._identities, fieldNumber: 3)
      }
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_SignaturePolicyEnvelope) -> Bool {
    return withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
      if _storage !== other_storage {
        if _storage._version != other_storage._version {return false}
        if _storage._policy != other_storage._policy {return false}
        if _storage._identities != other_storage._identities {return false}
      }
      return true
    }
  }
}

///   SignaturePolicy is a recursive message structure which defines a featherweight DSL for describing
///   policies which are more complicated than 'exactly this signature'.  The NOutOf operator is sufficent
///   to express AND as well as OR, as well as of course N out of the following M policies
///   SignedBy implies that the signature is from a valid certificate which is signed by the trusted
///   authority specified in the bytes.  This will be the certificate itself for a self-signed certificate
///   and will be the CA for more traditional certificates
struct Common_SignaturePolicy: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SignaturePolicy"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "signed_by", json: "signedBy"),
    2: .unique(proto: "n_out_of", json: "nOutOf"),
  ]

  private class _StorageClass {
    var _type: Common_SignaturePolicy.OneOf_Type?

    init() {}

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._type = _type
      return clone
    }
  }

  private var _storage = _StorageClass()

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }

  var signedBy: Int32 {
    get {
      if case .signedBy(let v)? = _storage._type {
        return v
      }
      return 0
    }
    set {
      _uniqueStorage()._type = .signedBy(newValue)
    }
  }

  var nOutOf: Common_SignaturePolicy.NOutOf {
    get {
      if case .nOutOf(let v)? = _storage._type {
        return v
      }
      return Common_SignaturePolicy.NOutOf()
    }
    set {
      _uniqueStorage()._type = .nOutOf(newValue)
    }
  }

  var type: OneOf_Type? {
    get {return _storage._type}
    set {
      _uniqueStorage()._type = newValue
    }
  }

  enum OneOf_Type: Equatable {
    case signedBy(Int32)
    case nOutOf(Common_SignaturePolicy.NOutOf)

    static func ==(lhs: Common_SignaturePolicy.OneOf_Type, rhs: Common_SignaturePolicy.OneOf_Type) -> Bool {
      switch (lhs, rhs) {
      case (.signedBy(let l), .signedBy(let r)): return l == r
      case (.nOutOf(let l), .nOutOf(let r)): return l == r
      default: return false
      }
    }

    fileprivate init?<T: SwiftProtobuf.Decoder>(byDecodingFrom decoder: inout T, fieldNumber: Int) throws {
      switch fieldNumber {
      case 1:
        var value = Int32()
        try decoder.decodeSingularInt32Field(value: &value)
        self = .signedBy(value)
        return
      case 2:
        var value: Common_SignaturePolicy.NOutOf?
        try decoder.decodeSingularMessageField(value: &value)
        if let value = value {
          self = .nOutOf(value)
          return
        }
      default:
        break
      }
      return nil
    }

    fileprivate func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V, start: Int, end: Int) throws {
      switch self {
      case .signedBy(let v):
        if start <= 1 && 1 < end {
          try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
        }
      case .nOutOf(let v):
        if start <= 2 && 2 < end {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }
      }
    }
  }

  struct NOutOf: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "NOutOf"
    static let protoPackageName: String = "common"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
      1: .same(proto: "N"),
      2: .same(proto: "policies"),
    ]

    var n: Int32 = 0

    var policies: [Common_SignaturePolicy] = []

    init() {}

    mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
      }
    }

    mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &n)
      case 2: try decoder.decodeRepeatedMessageField(value: &policies)
      default: break
      }
    }

    func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if n != 0 {
        try visitor.visitSingularInt32Field(value: n, fieldNumber: 1)
      }
      if !policies.isEmpty {
        try visitor.visitRepeatedMessageField(value: policies, fieldNumber: 2)
      }
    }

    func _protobuf_generated_isEqualTo(other: Common_SignaturePolicy.NOutOf) -> Bool {
      if n != other.n {return false}
      if policies != other.policies {return false}
      return true
    }
  }

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
      }
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1, 2:
      if _storage._type != nil {
        try decoder.handleConflictingOneOf()
      }
      _storage._type = try Common_SignaturePolicy.OneOf_Type(byDecodingFrom: &decoder, fieldNumber: fieldNumber)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      try _storage._type?.traverse(visitor: &visitor, start: 1, end: 3)
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_SignaturePolicy) -> Bool {
    return withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
      if _storage !== other_storage {
        if _storage._type != other_storage._type {return false}
      }
      return true
    }
  }
}

///   ImplicitMetaPolicy is a policy type which depends on the hierarchical nature of the configuration
///   It is implicit because the rule is generate implicitly based on the number of sub policies
///   It is meta because it depends only on the result of other policies
///   When evaluated, this policy iterates over all immediate child sub-groups, retrieves the policy
///   of name sub_policy, evaluates the collection and applies the rule.
///   For example, with 4 sub-groups, and a policy name of "foo", ImplicitMetaPolicy retrieves
///   each sub-group, retrieves policy "foo" for each subgroup, evaluates it, and, in the case of ANY
///   1 satisfied is sufficient, ALL would require 4 signatures, and MAJORITY would require 3 signatures.
struct Common_ImplicitMetaPolicy: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ImplicitMetaPolicy"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "sub_policy", json: "subPolicy"),
    2: .same(proto: "rule"),
  ]

  var subPolicy: String = ""

  var rule: Common_ImplicitMetaPolicy.Rule = Common_ImplicitMetaPolicy.Rule.any

  enum Rule: SwiftProtobuf.Enum, SwiftProtobuf._ProtoNameProviding {
    typealias RawValue = Int

    ///   Requires any of the sub-policies be satisfied, if no sub-policies exist, always returns true
    case any // = 0

    ///   Requires all of the sub-policies be satisfied
    case all // = 1

    ///   Requires a strict majority (greater than half) of the sub-policies be satisfied
    case majority // = 2
    case UNRECOGNIZED(Int)

    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
      0: .same(proto: "ANY"),
      1: .same(proto: "ALL"),
      2: .same(proto: "MAJORITY"),
    ]

    init() {
      self = .any
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .any
      case 1: self = .all
      case 2: self = .majority
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .any: return 0
      case .all: return 1
      case .majority: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularStringField(value: &subPolicy)
    case 2: try decoder.decodeSingularEnumField(value: &rule)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !subPolicy.isEmpty {
      try visitor.visitSingularStringField(value: subPolicy, fieldNumber: 1)
    }
    if rule != Common_ImplicitMetaPolicy.Rule.any {
      try visitor.visitSingularEnumField(value: rule, fieldNumber: 2)
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_ImplicitMetaPolicy) -> Bool {
    if subPolicy != other.subPolicy {return false}
    if rule != other.rule {return false}
    return true
  }
}

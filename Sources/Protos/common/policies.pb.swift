/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: common/policies.proto
 *
 */

// 
// Copyright IBM Corp. 2017 All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf


///   Policy expresses a policy which the orderer can evaluate, because there has been some desire expressed to support
///   multiple policy engines, this is typed as a oneof for now
struct Common_Policy: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_Policy"}
  public var protoMessageName: String {return "Policy"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "type", swift: "type"),
    2: .same(proto: "policy", swift: "policy"),
  ]


  enum PolicyType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///   Reserved to check for proper initialization
    case unknown // = 0
    case signature // = 1
    case msp // = 2
    case implicitMeta // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .signature
      case 2: self = .msp
      case 3: self = .implicitMeta
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    init?(name: String) {
      switch name {
      case "unknown": self = .unknown
      case "signature": self = .signature
      case "msp": self = .msp
      case "implicitMeta": self = .implicitMeta
      default: return nil
      }
    }

    init?(jsonName: String) {
      switch jsonName {
      case "UNKNOWN": self = .unknown
      case "SIGNATURE": self = .signature
      case "MSP": self = .msp
      case "IMPLICIT_META": self = .implicitMeta
      default: return nil
      }
    }

    init?(protoName: String) {
      switch protoName {
      case "UNKNOWN": self = .unknown
      case "SIGNATURE": self = .signature
      case "MSP": self = .msp
      case "IMPLICIT_META": self = .implicitMeta
      default: return nil
      }
    }

    var rawValue: Int {
      get {
        switch self {
        case .unknown: return 0
        case .signature: return 1
        case .msp: return 2
        case .implicitMeta: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }
    }

    var json: String {
      get {
        switch self {
        case .unknown: return "\"UNKNOWN\""
        case .signature: return "\"SIGNATURE\""
        case .msp: return "\"MSP\""
        case .implicitMeta: return "\"IMPLICIT_META\""
        case .UNRECOGNIZED(let i): return String(i)
        }
      }
    }

    var hashValue: Int { return rawValue }

    var debugDescription: String {
      get {
        switch self {
        case .unknown: return ".unknown"
        case .signature: return ".signature"
        case .msp: return ".msp"
        case .implicitMeta: return ".implicitMeta"
        case .UNRECOGNIZED(let v): return ".UNRECOGNIZED(\(v))"
        }
      }
    }

  }

  ///   For outside implementors, consider the first 1000 types reserved, otherwise one of PolicyType
  var type: Int32 = 0

  var policy: Data = Data()

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &type)
    case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &policy)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if type != 0 {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: type, fieldNumber: 1)
    }
    if policy != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: policy, fieldNumber: 2)
    }
  }

  public func _protoc_generated_isEqualTo(other: Common_Policy) -> Bool {
    if type != other.type {return false}
    if policy != other.policy {return false}
    return true
  }
}

///   SignaturePolicyEnvelope wraps a SignaturePolicy and includes a version for future enhancements
struct Common_SignaturePolicyEnvelope: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_SignaturePolicyEnvelope"}
  public var protoMessageName: String {return "SignaturePolicyEnvelope"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "version", swift: "version"),
    2: .same(proto: "policy", swift: "policy"),
    3: .same(proto: "identities", swift: "identities"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Common_SignaturePolicyEnvelope
    var _version: Int32 = 0
    var _policy: Common_SignaturePolicy? = nil
    var _identities: [Common_MSPPrincipal] = []

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &_version)
      case 2: try setter.decodeSingularMessageField(fieldType: Common_SignaturePolicy.self, value: &_policy)
      case 3: try setter.decodeRepeatedMessageField(fieldType: Common_MSPPrincipal.self, value: &_identities)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if _version != 0 {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: _version, fieldNumber: 1)
      }
      if let v = _policy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_identities.isEmpty {
        try visitor.visitRepeatedMessageField(value: _identities, fieldNumber: 3)
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _version != other._version {return false}
      if _policy != other._policy {return false}
      if _identities != other._identities {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._version = _version
      clone._policy = _policy
      clone._identities = _identities
      return clone
    }
  }

  private var _storage = _StorageClass()


  var version: Int32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  var policy: Common_SignaturePolicy {
    get {return _storage._policy ?? Common_SignaturePolicy()}
    set {_uniqueStorage()._policy = newValue}
  }
  public var hasPolicy: Bool {
    return _storage._policy != nil
  }
  public mutating func clearPolicy() {
    return _storage._policy = nil
  }

  var identities: [Common_MSPPrincipal] {
    get {return _storage._identities}
    set {_uniqueStorage()._identities = newValue}
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Common_SignaturePolicyEnvelope) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   SignaturePolicy is a recursive message structure which defines a featherweight DSL for describing
///   policies which are more complicated than 'exactly this signature'.  The NOutOf operator is sufficent
///   to express AND as well as OR, as well as of course N out of the following M policies
///   SignedBy implies that the signature is from a valid certificate which is signed by the trusted
///   authority specified in the bytes.  This will be the certificate itself for a self-signed certificate
///   and will be the CA for more traditional certificates
struct Common_SignaturePolicy: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_SignaturePolicy"}
  public var protoMessageName: String {return "SignaturePolicy"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .unique(proto: "signed_by", json: "signedBy", swift: "signedBy"),
    2: .unique(proto: "n_out_of", json: "nOutOf", swift: "nOutOf"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Common_SignaturePolicy
    var _type = Common_SignaturePolicy.OneOf_Type()

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1, 2: try _type.decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      try _type.traverse(visitor: visitor, start: 1, end: 3)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _type != other._type {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._type = _type
      return clone
    }
  }

  private var _storage = _StorageClass()


  enum OneOf_Type: ExpressibleByNilLiteral, SwiftProtobuf.OneofEnum {
    case signedBy(Int32)
    case nOutOf(Common_SignaturePolicy.NOutOf)
    case None

    static func ==(lhs: Common_SignaturePolicy.OneOf_Type, rhs: Common_SignaturePolicy.OneOf_Type) -> Bool {
      switch (lhs, rhs) {
      case (.signedBy(let l), .signedBy(let r)): return l == r
      case (.nOutOf(let l), .nOutOf(let r)): return l == r
      case (.None, .None): return true
      default: return false
      }
    }

    public init(nilLiteral: ()) {
      self = .None
    }

    public init() {
      self = .None
    }

    public mutating func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      if self != .None && setter.rejectConflictingOneof {
        throw SwiftProtobuf.DecodingError.duplicatedOneOf
      }
      switch protoFieldNumber {
      case 1:
        var value = Int32()
        try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &value)
        self = .signedBy(value)
      case 2:
        var value: Common_SignaturePolicy.NOutOf?
        try setter.decodeSingularMessageField(fieldType: Common_SignaturePolicy.NOutOf.self, value: &value)
        if let value = value {
          self = .nOutOf(value)
        }
      default:
        self = .None
      }
    }

    public func traverse(visitor: SwiftProtobuf.Visitor, start: Int, end: Int) throws {
      switch self {
      case .signedBy(let v):
        if start <= 1 && 1 < end {
          try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: v, fieldNumber: 1)
        }
      case .nOutOf(let v):
        if start <= 2 && 2 < end {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }
      case .None:
        break
      }
    }
  }

  struct NOutOf: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
    public var swiftClassName: String {return "Common_SignaturePolicy.NOutOf"}
    public var protoMessageName: String {return "NOutOf"}
    public var protoPackageName: String {return "common"}
    public static let _protobuf_fieldNames: FieldNameMap = [
      1: .same(proto: "N", swift: "n"),
      2: .same(proto: "policies", swift: "policies"),
    ]


    var n: Int32 = 0

    var policies: [Common_SignaturePolicy] = []

    init() {}

    public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &n)
      case 2: try setter.decodeRepeatedMessageField(fieldType: Common_SignaturePolicy.self, value: &policies)
      default: break
      }
    }

    public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
      if n != 0 {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: n, fieldNumber: 1)
      }
      if !policies.isEmpty {
        try visitor.visitRepeatedMessageField(value: policies, fieldNumber: 2)
      }
    }

    public func _protoc_generated_isEqualTo(other: Common_SignaturePolicy.NOutOf) -> Bool {
      if n != other.n {return false}
      if policies != other.policies {return false}
      return true
    }
  }

  var signedBy: Int32 {
    get {
      if case .signedBy(let v) = _storage._type {
        return v
      }
      return 0
    }
    set {
      _uniqueStorage()._type = .signedBy(newValue)
    }
  }

  var nOutOf: Common_SignaturePolicy.NOutOf {
    get {
      if case .nOutOf(let v) = _storage._type {
        return v
      }
      return Common_SignaturePolicy.NOutOf()
    }
    set {
      _uniqueStorage()._type = .nOutOf(newValue)
    }
  }

  public var type: OneOf_Type {
    get {return _storage._type}
    set {
      _uniqueStorage()._type = newValue
    }
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Common_SignaturePolicy) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   ImplicitMetaPolicy is a policy type which depends on the hierarchical nature of the configuration
///   It is implicit because the rule is generate implicitly based on the number of sub policies
///   It is meta because it depends only on the result of other policies
///   When evaluated, this policy iterates over all immediate child sub-groups, retrieves the policy
///   of name sub_policy, evaluates the collection and applies the rule.
///   For example, with 4 sub-groups, and a policy name of "foo", ImplicitMetaPolicy retrieves
///   each sub-group, retrieves policy "foo" for each subgroup, evaluates it, and, in the case of ANY
///   1 satisfied is sufficient, ALL would require 4 signatures, and MAJORITY would require 3 signatures.
struct Common_ImplicitMetaPolicy: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_ImplicitMetaPolicy"}
  public var protoMessageName: String {return "ImplicitMetaPolicy"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .unique(proto: "sub_policy", json: "subPolicy", swift: "subPolicy"),
    2: .same(proto: "rule", swift: "rule"),
  ]


  enum Rule: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///   Requires any of the sub-policies be satisfied, if no sub-policies exist, always returns true
    case any // = 0

    ///   Requires all of the sub-policies be satisfied
    case all // = 1

    ///   Requires a strict majority (greater than half) of the sub-policies be satisfied
    case majority // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .any
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .any
      case 1: self = .all
      case 2: self = .majority
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    init?(name: String) {
      switch name {
      case "any": self = .any
      case "all": self = .all
      case "majority": self = .majority
      default: return nil
      }
    }

    init?(jsonName: String) {
      switch jsonName {
      case "ANY": self = .any
      case "ALL": self = .all
      case "MAJORITY": self = .majority
      default: return nil
      }
    }

    init?(protoName: String) {
      switch protoName {
      case "ANY": self = .any
      case "ALL": self = .all
      case "MAJORITY": self = .majority
      default: return nil
      }
    }

    var rawValue: Int {
      get {
        switch self {
        case .any: return 0
        case .all: return 1
        case .majority: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }
    }

    var json: String {
      get {
        switch self {
        case .any: return "\"ANY\""
        case .all: return "\"ALL\""
        case .majority: return "\"MAJORITY\""
        case .UNRECOGNIZED(let i): return String(i)
        }
      }
    }

    var hashValue: Int { return rawValue }

    var debugDescription: String {
      get {
        switch self {
        case .any: return ".any"
        case .all: return ".all"
        case .majority: return ".majority"
        case .UNRECOGNIZED(let v): return ".UNRECOGNIZED(\(v))"
        }
      }
    }

  }

  var subPolicy: String = ""

  var rule: Common_ImplicitMetaPolicy.Rule = Common_ImplicitMetaPolicy.Rule.any

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &subPolicy)
    case 2: try setter.decodeSingularField(fieldType: Common_ImplicitMetaPolicy.Rule.self, value: &rule)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if subPolicy != "" {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: subPolicy, fieldNumber: 1)
    }
    if rule != Common_ImplicitMetaPolicy.Rule.any {
      try visitor.visitSingularField(fieldType: Common_ImplicitMetaPolicy.Rule.self, value: rule, fieldNumber: 2)
    }
  }

  public func _protoc_generated_isEqualTo(other: Common_ImplicitMetaPolicy) -> Bool {
    if subPolicy != other.subPolicy {return false}
    if rule != other.rule {return false}
    return true
  }
}

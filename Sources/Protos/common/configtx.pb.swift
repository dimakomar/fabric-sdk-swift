/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: common/configtx.proto
 *
 */

// 
// Copyright IBM Corp. 2017 All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//  XXX This is the older mechanism for specifying channel configuration
//  it is intended to be removed once there is no more dependency on it.

import Foundation
import SwiftProtobuf


///   ConfigEnvelope is designed to contain _all_ configuration for a chain with no dependency
///   on previous configuration transactions.
///  
///   It is generated with the following scheme:
///     1. Retrieve the existing configuration
///     2. Note the config properties (ConfigValue, ConfigPolicy, ConfigGroup) to be modified
///     3. Add any intermediate ConfigGroups to the ConfigUpdate.read_set (sparsely)
///     4. Add any additional desired dependencies to ConfigUpdate.read_set (sparsely)
///     5. Modify the config properties, incrementing each version by 1, set them in the ConfigUpdate.write_set
///        Note: any element not modified but specified should already be in the read_set, so may be specified sparsely
///     6. Create ConfigUpdate message and marshal it into ConfigUpdateEnvelope.update and encode the required signatures
///       a) Each signature is of type ConfigSignature
///       b) The ConfigSignature signature is over the concatenation of signature_header and the ConfigUpdate bytes (which includes a ChainHeader)
///     5. Submit new Config for ordering in Envelope signed by submitter
///       a) The Envelope Payload has data set to the marshaled ConfigEnvelope
///       b) The Envelope Payload has a header of type Header.Type.CONFIG_UPDATE
///  
///   The configuration manager will verify:
///     1. All items in the read_set exist at the read versions
///     2. All items in the write_set at a different version than, or not in, the read_set have been appropriately signed according to their mod_policy
///     3. The new configuration satisfies the ConfigSchema
struct Common_ConfigEnvelope: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_ConfigEnvelope"}
  public var protoMessageName: String {return "ConfigEnvelope"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "config", swift: "config"),
    2: .unique(proto: "last_update", json: "lastUpdate", swift: "lastUpdate"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Common_ConfigEnvelope
    var _config: Common_Config? = nil
    var _lastUpdate: Common_Envelope? = nil

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularMessageField(fieldType: Common_Config.self, value: &_config)
      case 2: try setter.decodeSingularMessageField(fieldType: Common_Envelope.self, value: &_lastUpdate)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if let v = _config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _lastUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _config != other._config {return false}
      if _lastUpdate != other._lastUpdate {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._config = _config
      clone._lastUpdate = _lastUpdate
      return clone
    }
  }

  private var _storage = _StorageClass()


  ///   A marshaled Config structure
  var config: Common_Config {
    get {return _storage._config ?? Common_Config()}
    set {_uniqueStorage()._config = newValue}
  }
  public var hasConfig: Bool {
    return _storage._config != nil
  }
  public mutating func clearConfig() {
    return _storage._config = nil
  }

  ///   The last CONFIG_UPDATE message which generated this current configuration
  var lastUpdate: Common_Envelope {
    get {return _storage._lastUpdate ?? Common_Envelope()}
    set {_uniqueStorage()._lastUpdate = newValue}
  }
  public var hasLastUpdate: Bool {
    return _storage._lastUpdate != nil
  }
  public mutating func clearLastUpdate() {
    return _storage._lastUpdate = nil
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Common_ConfigEnvelope) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

struct Common_ConfigGroupSchema: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_ConfigGroupSchema"}
  public var protoMessageName: String {return "ConfigGroupSchema"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "groups", swift: "groups"),
    2: .same(proto: "values", swift: "values"),
    3: .same(proto: "policies", swift: "policies"),
  ]


  var groups: Dictionary<String,Common_ConfigGroupSchema> = [:]

  var values: Dictionary<String,Common_ConfigValueSchema> = [:]

  var policies: Dictionary<String,Common_ConfigPolicySchema> = [:]

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeMapField(fieldType: SwiftProtobuf.ProtobufMap<SwiftProtobuf.ProtobufString,Common_ConfigGroupSchema>.self, value: &groups)
    case 2: try setter.decodeMapField(fieldType: SwiftProtobuf.ProtobufMap<SwiftProtobuf.ProtobufString,Common_ConfigValueSchema>.self, value: &values)
    case 3: try setter.decodeMapField(fieldType: SwiftProtobuf.ProtobufMap<SwiftProtobuf.ProtobufString,Common_ConfigPolicySchema>.self, value: &policies)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if !groups.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf.ProtobufMap<SwiftProtobuf.ProtobufString,Common_ConfigGroupSchema>.self, value: groups, fieldNumber: 1)
    }
    if !values.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf.ProtobufMap<SwiftProtobuf.ProtobufString,Common_ConfigValueSchema>.self, value: values, fieldNumber: 2)
    }
    if !policies.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf.ProtobufMap<SwiftProtobuf.ProtobufString,Common_ConfigPolicySchema>.self, value: policies, fieldNumber: 3)
    }
  }

  public func _protoc_generated_isEqualTo(other: Common_ConfigGroupSchema) -> Bool {
    if groups != other.groups {return false}
    if values != other.values {return false}
    if policies != other.policies {return false}
    return true
  }
}

struct Common_ConfigValueSchema: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_ConfigValueSchema"}
  public var protoMessageName: String {return "ConfigValueSchema"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames = FieldNameMap()


  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
  }

  public func _protoc_generated_isEqualTo(other: Common_ConfigValueSchema) -> Bool {
    return true
  }
}

struct Common_ConfigPolicySchema: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_ConfigPolicySchema"}
  public var protoMessageName: String {return "ConfigPolicySchema"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames = FieldNameMap()


  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
  }

  public func _protoc_generated_isEqualTo(other: Common_ConfigPolicySchema) -> Bool {
    return true
  }
}

///   Config represents the config for a particular channel
struct Common_Config: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_Config"}
  public var protoMessageName: String {return "Config"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "header", swift: "header"),
    2: .same(proto: "channel", swift: "channel"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Common_Config
    var _header: Common_ChannelHeader? = nil
    var _channel: Common_ConfigGroup? = nil

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularMessageField(fieldType: Common_ChannelHeader.self, value: &_header)
      case 2: try setter.decodeSingularMessageField(fieldType: Common_ConfigGroup.self, value: &_channel)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if let v = _header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _channel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _header != other._header {return false}
      if _channel != other._channel {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._header = _header
      clone._channel = _channel
      return clone
    }
  }

  private var _storage = _StorageClass()


  var header: Common_ChannelHeader {
    get {return _storage._header ?? Common_ChannelHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  public var hasHeader: Bool {
    return _storage._header != nil
  }
  public mutating func clearHeader() {
    return _storage._header = nil
  }

  var channel: Common_ConfigGroup {
    get {return _storage._channel ?? Common_ConfigGroup()}
    set {_uniqueStorage()._channel = newValue}
  }
  public var hasChannel: Bool {
    return _storage._channel != nil
  }
  public mutating func clearChannel() {
    return _storage._channel = nil
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Common_Config) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

struct Common_ConfigUpdateEnvelope: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_ConfigUpdateEnvelope"}
  public var protoMessageName: String {return "ConfigUpdateEnvelope"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .unique(proto: "config_update", json: "configUpdate", swift: "configUpdate"),
    2: .same(proto: "signatures", swift: "signatures"),
  ]


  ///   A marshaled ConfigUpdate structure
  var configUpdate: Data = Data()

  ///   Signatures over the config_update
  var signatures: [Common_ConfigSignature] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &configUpdate)
    case 2: try setter.decodeRepeatedMessageField(fieldType: Common_ConfigSignature.self, value: &signatures)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if configUpdate != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: configUpdate, fieldNumber: 1)
    }
    if !signatures.isEmpty {
      try visitor.visitRepeatedMessageField(value: signatures, fieldNumber: 2)
    }
  }

  public func _protoc_generated_isEqualTo(other: Common_ConfigUpdateEnvelope) -> Bool {
    if configUpdate != other.configUpdate {return false}
    if signatures != other.signatures {return false}
    return true
  }
}

///   ConfigUpdate is used to submit a subset of config and to have the orderer apply to Config
///   it is always submitted inside a ConfigUpdateEnvelope which allows the addition of signatures
///   resulting in a new total configuration.  The update is applied as follows:
///   1. The versions from all of the elements in the read_set is verified against the versions in the existing config.
///      If there is a mismatch in the read versions, then the config update fails and is rejected.
///   2. Any elements in the write_set with the same version as the read_set are ignored.
///   3. The corresponding mod_policy for every remaining element in the write_set is collected.
///   4. Each policy is checked against the signatures from the ConfigUpdateEnvelope, any failing to verify are rejected
///   5. The write_set is applied to the Config and the ConfigGroupSchema verifies that the updates were legal
struct Common_ConfigUpdate: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_ConfigUpdate"}
  public var protoMessageName: String {return "ConfigUpdate"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "header", swift: "header"),
    2: .unique(proto: "read_set", json: "readSet", swift: "readSet"),
    3: .unique(proto: "write_set", json: "writeSet", swift: "writeSet"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Common_ConfigUpdate
    var _header: Common_ChannelHeader? = nil
    var _readSet: Common_ConfigGroup? = nil
    var _writeSet: Common_ConfigGroup? = nil

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularMessageField(fieldType: Common_ChannelHeader.self, value: &_header)
      case 2: try setter.decodeSingularMessageField(fieldType: Common_ConfigGroup.self, value: &_readSet)
      case 3: try setter.decodeSingularMessageField(fieldType: Common_ConfigGroup.self, value: &_writeSet)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if let v = _header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _readSet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _writeSet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _header != other._header {return false}
      if _readSet != other._readSet {return false}
      if _writeSet != other._writeSet {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._header = _header
      clone._readSet = _readSet
      clone._writeSet = _writeSet
      return clone
    }
  }

  private var _storage = _StorageClass()


  ///   Header scopes the update to a particular Channel
  var header: Common_ChannelHeader {
    get {return _storage._header ?? Common_ChannelHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  public var hasHeader: Bool {
    return _storage._header != nil
  }
  public mutating func clearHeader() {
    return _storage._header = nil
  }

  ///   ReadSet explicitly lists the portion of the config which was read, this should be sparse with only Version set
  var readSet: Common_ConfigGroup {
    get {return _storage._readSet ?? Common_ConfigGroup()}
    set {_uniqueStorage()._readSet = newValue}
  }
  public var hasReadSet: Bool {
    return _storage._readSet != nil
  }
  public mutating func clearReadSet() {
    return _storage._readSet = nil
  }

  ///   WriteSet lists the portion of the config which was written, this should included updated Versions
  var writeSet: Common_ConfigGroup {
    get {return _storage._writeSet ?? Common_ConfigGroup()}
    set {_uniqueStorage()._writeSet = newValue}
  }
  public var hasWriteSet: Bool {
    return _storage._writeSet != nil
  }
  public mutating func clearWriteSet() {
    return _storage._writeSet = nil
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Common_ConfigUpdate) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   ConfigGroup is the hierarchical data structure for holding config
struct Common_ConfigGroup: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_ConfigGroup"}
  public var protoMessageName: String {return "ConfigGroup"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "version", swift: "version"),
    2: .same(proto: "groups", swift: "groups"),
    3: .same(proto: "values", swift: "values"),
    4: .same(proto: "policies", swift: "policies"),
    5: .unique(proto: "mod_policy", json: "modPolicy", swift: "modPolicy"),
  ]


  var version: UInt64 = 0

  var groups: Dictionary<String,Common_ConfigGroup> = [:]

  var values: Dictionary<String,Common_ConfigValue> = [:]

  var policies: Dictionary<String,Common_ConfigPolicy> = [:]

  var modPolicy: String = ""

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufUInt64.self, value: &version)
    case 2: try setter.decodeMapField(fieldType: SwiftProtobuf.ProtobufMap<SwiftProtobuf.ProtobufString,Common_ConfigGroup>.self, value: &groups)
    case 3: try setter.decodeMapField(fieldType: SwiftProtobuf.ProtobufMap<SwiftProtobuf.ProtobufString,Common_ConfigValue>.self, value: &values)
    case 4: try setter.decodeMapField(fieldType: SwiftProtobuf.ProtobufMap<SwiftProtobuf.ProtobufString,Common_ConfigPolicy>.self, value: &policies)
    case 5: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &modPolicy)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if version != 0 {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufUInt64.self, value: version, fieldNumber: 1)
    }
    if !groups.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf.ProtobufMap<SwiftProtobuf.ProtobufString,Common_ConfigGroup>.self, value: groups, fieldNumber: 2)
    }
    if !values.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf.ProtobufMap<SwiftProtobuf.ProtobufString,Common_ConfigValue>.self, value: values, fieldNumber: 3)
    }
    if !policies.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf.ProtobufMap<SwiftProtobuf.ProtobufString,Common_ConfigPolicy>.self, value: policies, fieldNumber: 4)
    }
    if modPolicy != "" {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: modPolicy, fieldNumber: 5)
    }
  }

  public func _protoc_generated_isEqualTo(other: Common_ConfigGroup) -> Bool {
    if version != other.version {return false}
    if groups != other.groups {return false}
    if values != other.values {return false}
    if policies != other.policies {return false}
    if modPolicy != other.modPolicy {return false}
    return true
  }
}

///   ConfigValue represents an individual piece of config data
struct Common_ConfigValue: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_ConfigValue"}
  public var protoMessageName: String {return "ConfigValue"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "version", swift: "version"),
    2: .same(proto: "value", swift: "value"),
    3: .unique(proto: "mod_policy", json: "modPolicy", swift: "modPolicy"),
  ]


  var version: UInt64 = 0

  var value: Data = Data()

  var modPolicy: String = ""

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufUInt64.self, value: &version)
    case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &value)
    case 3: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &modPolicy)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if version != 0 {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufUInt64.self, value: version, fieldNumber: 1)
    }
    if value != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: value, fieldNumber: 2)
    }
    if modPolicy != "" {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: modPolicy, fieldNumber: 3)
    }
  }

  public func _protoc_generated_isEqualTo(other: Common_ConfigValue) -> Bool {
    if version != other.version {return false}
    if value != other.value {return false}
    if modPolicy != other.modPolicy {return false}
    return true
  }
}

struct Common_ConfigPolicy: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_ConfigPolicy"}
  public var protoMessageName: String {return "ConfigPolicy"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "version", swift: "version"),
    2: .same(proto: "policy", swift: "policy"),
    3: .unique(proto: "mod_policy", json: "modPolicy", swift: "modPolicy"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Common_ConfigPolicy
    var _version: UInt64 = 0
    var _policy: Common_Policy? = nil
    var _modPolicy: String = ""

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufUInt64.self, value: &_version)
      case 2: try setter.decodeSingularMessageField(fieldType: Common_Policy.self, value: &_policy)
      case 3: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &_modPolicy)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if _version != 0 {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufUInt64.self, value: _version, fieldNumber: 1)
      }
      if let v = _policy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _modPolicy != "" {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: _modPolicy, fieldNumber: 3)
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _version != other._version {return false}
      if _policy != other._policy {return false}
      if _modPolicy != other._modPolicy {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._version = _version
      clone._policy = _policy
      clone._modPolicy = _modPolicy
      return clone
    }
  }

  private var _storage = _StorageClass()


  var version: UInt64 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  var policy: Common_Policy {
    get {return _storage._policy ?? Common_Policy()}
    set {_uniqueStorage()._policy = newValue}
  }
  public var hasPolicy: Bool {
    return _storage._policy != nil
  }
  public mutating func clearPolicy() {
    return _storage._policy = nil
  }

  var modPolicy: String {
    get {return _storage._modPolicy}
    set {_uniqueStorage()._modPolicy = newValue}
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Common_ConfigPolicy) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

struct Common_ConfigSignature: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Common_ConfigSignature"}
  public var protoMessageName: String {return "ConfigSignature"}
  public var protoPackageName: String {return "common"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .unique(proto: "signature_header", json: "signatureHeader", swift: "signatureHeader"),
    2: .same(proto: "signature", swift: "signature"),
  ]


  ///   A marshaled SignatureHeader
  var signatureHeader: Data = Data()

  ///   Signature over the concatenation signatureHeader bytes and config bytes
  var signature: Data = Data()

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &signatureHeader)
    case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &signature)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if signatureHeader != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: signatureHeader, fieldNumber: 1)
    }
    if signature != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: signature, fieldNumber: 2)
    }
  }

  public func _protoc_generated_isEqualTo(other: Common_ConfigSignature) -> Bool {
    if signatureHeader != other.signatureHeader {return false}
    if signature != other.signature {return false}
    return true
  }
}

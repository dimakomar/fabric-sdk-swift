/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: common/configtx.proto
 *
 */

// 
// Copyright IBM Corp. 2017 All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _1: SwiftProtobuf.ProtobufAPIVersion_1 {}
  typealias Version = _1
}

///   ConfigEnvelope is designed to contain _all_ configuration for a chain with no dependency
///   on previous configuration transactions.
///  
///   It is generated with the following scheme:
///     1. Retrieve the existing configuration
///     2. Note the config properties (ConfigValue, ConfigPolicy, ConfigGroup) to be modified
///     3. Add any intermediate ConfigGroups to the ConfigUpdate.read_set (sparsely)
///     4. Add any additional desired dependencies to ConfigUpdate.read_set (sparsely)
///     5. Modify the config properties, incrementing each version by 1, set them in the ConfigUpdate.write_set
///        Note: any element not modified but specified should already be in the read_set, so may be specified sparsely
///     6. Create ConfigUpdate message and marshal it into ConfigUpdateEnvelope.update and encode the required signatures
///       a) Each signature is of type ConfigSignature
///       b) The ConfigSignature signature is over the concatenation of signature_header and the ConfigUpdate bytes (which includes a ChainHeader)
///     5. Submit new Config for ordering in Envelope signed by submitter
///       a) The Envelope Payload has data set to the marshaled ConfigEnvelope
///       b) The Envelope Payload has a header of type Header.Type.CONFIG_UPDATE
///  
///   The configuration manager will verify:
///     1. All items in the read_set exist at the read versions
///     2. All items in the write_set at a different version than, or not in, the read_set have been appropriately signed according to their mod_policy
///     3. The new configuration satisfies the ConfigSchema
struct Common_ConfigEnvelope: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ConfigEnvelope"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
    2: .unique(proto: "last_update", json: "lastUpdate"),
  ]

  private class _StorageClass {
    var _config: Common_Config? = nil
    var _lastUpdate: Common_Envelope? = nil

    init() {}

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._config = _config
      clone._lastUpdate = _lastUpdate
      return clone
    }
  }

  private var _storage = _StorageClass()

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }

  ///   A marshaled Config structure
  var config: Common_Config {
    get {return _storage._config ?? Common_Config()}
    set {_uniqueStorage()._config = newValue}
  }
  var hasConfig: Bool {
    return _storage._config != nil
  }
  mutating func clearConfig() {
    return _storage._config = nil
  }

  ///   The last CONFIG_UPDATE message which generated this current configuration
  var lastUpdate: Common_Envelope {
    get {return _storage._lastUpdate ?? Common_Envelope()}
    set {_uniqueStorage()._lastUpdate = newValue}
  }
  var hasLastUpdate: Bool {
    return _storage._lastUpdate != nil
  }
  mutating func clearLastUpdate() {
    return _storage._lastUpdate = nil
  }

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
      }
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularMessageField(value: &_storage._config)
    case 2: try decoder.decodeSingularMessageField(value: &_storage._lastUpdate)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._lastUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_ConfigEnvelope) -> Bool {
    return withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
      if _storage !== other_storage {
        if _storage._config != other_storage._config {return false}
        if _storage._lastUpdate != other_storage._lastUpdate {return false}
      }
      return true
    }
  }
}

struct Common_ConfigGroupSchema: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ConfigGroupSchema"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groups"),
    2: .same(proto: "values"),
    3: .same(proto: "policies"),
  ]

  var groups: Dictionary<String,Common_ConfigGroupSchema> = [:]

  var values: Dictionary<String,Common_ConfigValueSchema> = [:]

  var policies: Dictionary<String,Common_ConfigPolicySchema> = [:]

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Common_ConfigGroupSchema>.self, value: &groups)
    case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Common_ConfigValueSchema>.self, value: &values)
    case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Common_ConfigPolicySchema>.self, value: &policies)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !groups.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Common_ConfigGroupSchema>.self, value: groups, fieldNumber: 1)
    }
    if !values.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Common_ConfigValueSchema>.self, value: values, fieldNumber: 2)
    }
    if !policies.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Common_ConfigPolicySchema>.self, value: policies, fieldNumber: 3)
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_ConfigGroupSchema) -> Bool {
    if groups != other.groups {return false}
    if values != other.values {return false}
    if policies != other.policies {return false}
    return true
  }
}

struct Common_ConfigValueSchema: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ConfigValueSchema"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
  }

  func _protobuf_generated_isEqualTo(other: Common_ConfigValueSchema) -> Bool {
    return true
  }
}

struct Common_ConfigPolicySchema: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ConfigPolicySchema"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
  }

  func _protobuf_generated_isEqualTo(other: Common_ConfigPolicySchema) -> Bool {
    return true
  }
}

///   Config represents the config for a particular channel
struct Common_Config: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Config"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sequence"),
    2: .unique(proto: "channel_group", json: "channelGroup"),
  ]

  private class _StorageClass {
    var _sequence: UInt64 = 0
    var _channelGroup: Common_ConfigGroup? = nil

    init() {}

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._sequence = _sequence
      clone._channelGroup = _channelGroup
      return clone
    }
  }

  private var _storage = _StorageClass()

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }

  var sequence: UInt64 {
    get {return _storage._sequence}
    set {_uniqueStorage()._sequence = newValue}
  }

  var channelGroup: Common_ConfigGroup {
    get {return _storage._channelGroup ?? Common_ConfigGroup()}
    set {_uniqueStorage()._channelGroup = newValue}
  }
  var hasChannelGroup: Bool {
    return _storage._channelGroup != nil
  }
  mutating func clearChannelGroup() {
    return _storage._channelGroup = nil
  }

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
      }
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularUInt64Field(value: &_storage._sequence)
    case 2: try decoder.decodeSingularMessageField(value: &_storage._channelGroup)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._sequence != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._sequence, fieldNumber: 1)
      }
      if let v = _storage._channelGroup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_Config) -> Bool {
    return withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
      if _storage !== other_storage {
        if _storage._sequence != other_storage._sequence {return false}
        if _storage._channelGroup != other_storage._channelGroup {return false}
      }
      return true
    }
  }
}

struct Common_ConfigUpdateEnvelope: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ConfigUpdateEnvelope"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "config_update", json: "configUpdate"),
    2: .same(proto: "signatures"),
  ]

  ///   A marshaled ConfigUpdate structure
  var configUpdate: Data = Data()

  ///   Signatures over the config_update
  var signatures: [Common_ConfigSignature] = []

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularBytesField(value: &configUpdate)
    case 2: try decoder.decodeRepeatedMessageField(value: &signatures)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !configUpdate.isEmpty {
      try visitor.visitSingularBytesField(value: configUpdate, fieldNumber: 1)
    }
    if !signatures.isEmpty {
      try visitor.visitRepeatedMessageField(value: signatures, fieldNumber: 2)
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_ConfigUpdateEnvelope) -> Bool {
    if configUpdate != other.configUpdate {return false}
    if signatures != other.signatures {return false}
    return true
  }
}

///   ConfigUpdate is used to submit a subset of config and to have the orderer apply to Config
///   it is always submitted inside a ConfigUpdateEnvelope which allows the addition of signatures
///   resulting in a new total configuration.  The update is applied as follows:
///   1. The versions from all of the elements in the read_set is verified against the versions in the existing config.
///      If there is a mismatch in the read versions, then the config update fails and is rejected.
///   2. Any elements in the write_set with the same version as the read_set are ignored.
///   3. The corresponding mod_policy for every remaining element in the write_set is collected.
///   4. Each policy is checked against the signatures from the ConfigUpdateEnvelope, any failing to verify are rejected
///   5. The write_set is applied to the Config and the ConfigGroupSchema verifies that the updates were legal
struct Common_ConfigUpdate: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ConfigUpdate"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "channel_id", json: "channelId"),
    2: .unique(proto: "read_set", json: "readSet"),
    3: .unique(proto: "write_set", json: "writeSet"),
  ]

  private class _StorageClass {
    var _channelId: String = ""
    var _readSet: Common_ConfigGroup? = nil
    var _writeSet: Common_ConfigGroup? = nil

    init() {}

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._channelId = _channelId
      clone._readSet = _readSet
      clone._writeSet = _writeSet
      return clone
    }
  }

  private var _storage = _StorageClass()

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }

  ///   Which channel this config update is for
  var channelId: String {
    get {return _storage._channelId}
    set {_uniqueStorage()._channelId = newValue}
  }

  ///   ReadSet explicitly lists the portion of the config which was read, this should be sparse with only Version set
  var readSet: Common_ConfigGroup {
    get {return _storage._readSet ?? Common_ConfigGroup()}
    set {_uniqueStorage()._readSet = newValue}
  }
  var hasReadSet: Bool {
    return _storage._readSet != nil
  }
  mutating func clearReadSet() {
    return _storage._readSet = nil
  }

  ///   WriteSet lists the portion of the config which was written, this should included updated Versions
  var writeSet: Common_ConfigGroup {
    get {return _storage._writeSet ?? Common_ConfigGroup()}
    set {_uniqueStorage()._writeSet = newValue}
  }
  var hasWriteSet: Bool {
    return _storage._writeSet != nil
  }
  mutating func clearWriteSet() {
    return _storage._writeSet = nil
  }

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
      }
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularStringField(value: &_storage._channelId)
    case 2: try decoder.decodeSingularMessageField(value: &_storage._readSet)
    case 3: try decoder.decodeSingularMessageField(value: &_storage._writeSet)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._channelId.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelId, fieldNumber: 1)
      }
      if let v = _storage._readSet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._writeSet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_ConfigUpdate) -> Bool {
    return withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
      if _storage !== other_storage {
        if _storage._channelId != other_storage._channelId {return false}
        if _storage._readSet != other_storage._readSet {return false}
        if _storage._writeSet != other_storage._writeSet {return false}
      }
      return true
    }
  }
}

///   ConfigGroup is the hierarchical data structure for holding config
struct Common_ConfigGroup: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ConfigGroup"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "groups"),
    3: .same(proto: "values"),
    4: .same(proto: "policies"),
    5: .unique(proto: "mod_policy", json: "modPolicy"),
  ]

  var version: UInt64 = 0

  var groups: Dictionary<String,Common_ConfigGroup> = [:]

  var values: Dictionary<String,Common_ConfigValue> = [:]

  var policies: Dictionary<String,Common_ConfigPolicy> = [:]

  var modPolicy: String = ""

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularUInt64Field(value: &version)
    case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Common_ConfigGroup>.self, value: &groups)
    case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Common_ConfigValue>.self, value: &values)
    case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Common_ConfigPolicy>.self, value: &policies)
    case 5: try decoder.decodeSingularStringField(value: &modPolicy)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if version != 0 {
      try visitor.visitSingularUInt64Field(value: version, fieldNumber: 1)
    }
    if !groups.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Common_ConfigGroup>.self, value: groups, fieldNumber: 2)
    }
    if !values.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Common_ConfigValue>.self, value: values, fieldNumber: 3)
    }
    if !policies.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Common_ConfigPolicy>.self, value: policies, fieldNumber: 4)
    }
    if !modPolicy.isEmpty {
      try visitor.visitSingularStringField(value: modPolicy, fieldNumber: 5)
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_ConfigGroup) -> Bool {
    if version != other.version {return false}
    if groups != other.groups {return false}
    if values != other.values {return false}
    if policies != other.policies {return false}
    if modPolicy != other.modPolicy {return false}
    return true
  }
}

///   ConfigValue represents an individual piece of config data
struct Common_ConfigValue: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ConfigValue"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "value"),
    3: .unique(proto: "mod_policy", json: "modPolicy"),
  ]

  var version: UInt64 = 0

  var value: Data = Data()

  var modPolicy: String = ""

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularUInt64Field(value: &version)
    case 2: try decoder.decodeSingularBytesField(value: &value)
    case 3: try decoder.decodeSingularStringField(value: &modPolicy)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if version != 0 {
      try visitor.visitSingularUInt64Field(value: version, fieldNumber: 1)
    }
    if !value.isEmpty {
      try visitor.visitSingularBytesField(value: value, fieldNumber: 2)
    }
    if !modPolicy.isEmpty {
      try visitor.visitSingularStringField(value: modPolicy, fieldNumber: 3)
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_ConfigValue) -> Bool {
    if version != other.version {return false}
    if value != other.value {return false}
    if modPolicy != other.modPolicy {return false}
    return true
  }
}

struct Common_ConfigPolicy: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ConfigPolicy"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "policy"),
    3: .unique(proto: "mod_policy", json: "modPolicy"),
  ]

  private class _StorageClass {
    var _version: UInt64 = 0
    var _policy: Common_Policy? = nil
    var _modPolicy: String = ""

    init() {}

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._version = _version
      clone._policy = _policy
      clone._modPolicy = _modPolicy
      return clone
    }
  }

  private var _storage = _StorageClass()

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }

  var version: UInt64 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  var policy: Common_Policy {
    get {return _storage._policy ?? Common_Policy()}
    set {_uniqueStorage()._policy = newValue}
  }
  var hasPolicy: Bool {
    return _storage._policy != nil
  }
  mutating func clearPolicy() {
    return _storage._policy = nil
  }

  var modPolicy: String {
    get {return _storage._modPolicy}
    set {_uniqueStorage()._modPolicy = newValue}
  }

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
      }
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularUInt64Field(value: &_storage._version)
    case 2: try decoder.decodeSingularMessageField(value: &_storage._policy)
    case 3: try decoder.decodeSingularStringField(value: &_storage._modPolicy)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._version != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._version, fieldNumber: 1)
      }
      if let v = _storage._policy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._modPolicy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._modPolicy, fieldNumber: 3)
      }
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_ConfigPolicy) -> Bool {
    return withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
      if _storage !== other_storage {
        if _storage._version != other_storage._version {return false}
        if _storage._policy != other_storage._policy {return false}
        if _storage._modPolicy != other_storage._modPolicy {return false}
      }
      return true
    }
  }
}

struct Common_ConfigSignature: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ConfigSignature"
  static let protoPackageName: String = "common"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "signature_header", json: "signatureHeader"),
    2: .same(proto: "signature"),
  ]

  ///   A marshaled SignatureHeader
  var signatureHeader: Data = Data()

  ///   Signature over the concatenation signatureHeader bytes and config bytes
  var signature: Data = Data()

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularBytesField(value: &signatureHeader)
    case 2: try decoder.decodeSingularBytesField(value: &signature)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !signatureHeader.isEmpty {
      try visitor.visitSingularBytesField(value: signatureHeader, fieldNumber: 1)
    }
    if !signature.isEmpty {
      try visitor.visitSingularBytesField(value: signature, fieldNumber: 2)
    }
  }

  func _protobuf_generated_isEqualTo(other: Common_ConfigSignature) -> Bool {
    if signatureHeader != other.signatureHeader {return false}
    if signature != other.signature {return false}
    return true
  }
}

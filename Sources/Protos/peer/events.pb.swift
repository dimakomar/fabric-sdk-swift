/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: peer/events.proto
 *
 */

// 
// Copyright IBM Corp. 2016 All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _1: SwiftProtobuf.ProtobufAPIVersion_1 {}
  typealias Version = _1
}

// ----Event objects----

enum Protos_EventType: SwiftProtobuf.Enum, SwiftProtobuf._ProtoNameProviding {
  typealias RawValue = Int
  case register // = 0
  case block // = 1
  case chaincode // = 2
  case rejection // = 3
  case UNRECOGNIZED(Int)

  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REGISTER"),
    1: .same(proto: "BLOCK"),
    2: .same(proto: "CHAINCODE"),
    3: .same(proto: "REJECTION"),
  ]

  init() {
    self = .register
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .register
    case 1: self = .block
    case 2: self = .chaincode
    case 3: self = .rejection
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .register: return 0
    case .block: return 1
    case .chaincode: return 2
    case .rejection: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

///  ChaincodeReg is used for registering chaincode Interests
///  when EventType is CHAINCODE
struct Protos_ChaincodeReg: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChaincodeReg"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "chaincode_id", json: "chaincodeId"),
    2: .unique(proto: "event_name", json: "eventName"),
  ]

  var chaincodeId: String = ""

  var eventName: String = ""

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularStringField(value: &chaincodeId)
    case 2: try decoder.decodeSingularStringField(value: &eventName)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !chaincodeId.isEmpty {
      try visitor.visitSingularStringField(value: chaincodeId, fieldNumber: 1)
    }
    if !eventName.isEmpty {
      try visitor.visitSingularStringField(value: eventName, fieldNumber: 2)
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_ChaincodeReg) -> Bool {
    if chaincodeId != other.chaincodeId {return false}
    if eventName != other.eventName {return false}
    return true
  }
}

struct Protos_Interest: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Interest"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "event_type", json: "eventType"),
    2: .unique(proto: "chaincode_reg_info", json: "chaincodeRegInfo"),
    3: .same(proto: "chainID"),
  ]

  private class _StorageClass {
    var _eventType: Protos_EventType = Protos_EventType.register
    var _regInfo: Protos_Interest.OneOf_RegInfo?
    var _chainId: String = ""

    init() {}

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._eventType = _eventType
      clone._regInfo = _regInfo
      clone._chainId = _chainId
      return clone
    }
  }

  private var _storage = _StorageClass()

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }

  var eventType: Protos_EventType {
    get {return _storage._eventType}
    set {_uniqueStorage()._eventType = newValue}
  }

  var chaincodeRegInfo: Protos_ChaincodeReg {
    get {
      if case .chaincodeRegInfo(let v)? = _storage._regInfo {
        return v
      }
      return Protos_ChaincodeReg()
    }
    set {
      _uniqueStorage()._regInfo = .chaincodeRegInfo(newValue)
    }
  }

  var chainId: String {
    get {return _storage._chainId}
    set {_uniqueStorage()._chainId = newValue}
  }

  var regInfo: OneOf_RegInfo? {
    get {return _storage._regInfo}
    set {
      _uniqueStorage()._regInfo = newValue
    }
  }

  enum OneOf_RegInfo: Equatable {
    case chaincodeRegInfo(Protos_ChaincodeReg)

    static func ==(lhs: Protos_Interest.OneOf_RegInfo, rhs: Protos_Interest.OneOf_RegInfo) -> Bool {
      switch (lhs, rhs) {
      case (.chaincodeRegInfo(let l), .chaincodeRegInfo(let r)): return l == r
      }
    }

    fileprivate init?<T: SwiftProtobuf.Decoder>(byDecodingFrom decoder: inout T, fieldNumber: Int) throws {
      switch fieldNumber {
      case 2:
        var value: Protos_ChaincodeReg?
        try decoder.decodeSingularMessageField(value: &value)
        if let value = value {
          self = .chaincodeRegInfo(value)
          return
        }
      default:
        break
      }
      return nil
    }

    fileprivate func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V, start: Int, end: Int) throws {
      switch self {
      case .chaincodeRegInfo(let v):
        if start <= 2 && 2 < end {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }
      }
    }
  }

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
      }
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularEnumField(value: &_storage._eventType)
    case 2:
      if _storage._regInfo != nil {
        try decoder.handleConflictingOneOf()
      }
      _storage._regInfo = try Protos_Interest.OneOf_RegInfo(byDecodingFrom: &decoder, fieldNumber: fieldNumber)
    case 3: try decoder.decodeSingularStringField(value: &_storage._chainId)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._eventType != Protos_EventType.register {
        try visitor.visitSingularEnumField(value: _storage._eventType, fieldNumber: 1)
      }
      try _storage._regInfo?.traverse(visitor: &visitor, start: 2, end: 3)
      if !_storage._chainId.isEmpty {
        try visitor.visitSingularStringField(value: _storage._chainId, fieldNumber: 3)
      }
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_Interest) -> Bool {
    return withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
      if _storage !== other_storage {
        if _storage._eventType != other_storage._eventType {return false}
        if _storage._regInfo != other_storage._regInfo {return false}
        if _storage._chainId != other_storage._chainId {return false}
      }
      return true
    }
  }
}

///  ---------- consumer events ---------
///  Register is sent by consumers for registering events
///  string type - "register"
struct Protos_Register: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Register"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
  ]

  var events: [Protos_Interest] = []

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeRepeatedMessageField(value: &events)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !events.isEmpty {
      try visitor.visitRepeatedMessageField(value: events, fieldNumber: 1)
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_Register) -> Bool {
    if events != other.events {return false}
    return true
  }
}

///  Rejection is sent by consumers for erroneous transaction rejection events
///  string type - "rejection"
struct Protos_Rejection: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Rejection"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx"),
    2: .unique(proto: "error_msg", json: "errorMsg"),
  ]

  private class _StorageClass {
    var _tx: Protos_Transaction? = nil
    var _errorMsg: String = ""

    init() {}

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._tx = _tx
      clone._errorMsg = _errorMsg
      return clone
    }
  }

  private var _storage = _StorageClass()

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }

  var tx: Protos_Transaction {
    get {return _storage._tx ?? Protos_Transaction()}
    set {_uniqueStorage()._tx = newValue}
  }
  var hasTx: Bool {
    return _storage._tx != nil
  }
  mutating func clearTx() {
    return _storage._tx = nil
  }

  var errorMsg: String {
    get {return _storage._errorMsg}
    set {_uniqueStorage()._errorMsg = newValue}
  }

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
      }
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularMessageField(value: &_storage._tx)
    case 2: try decoder.decodeSingularStringField(value: &_storage._errorMsg)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._tx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._errorMsg.isEmpty {
        try visitor.visitSingularStringField(value: _storage._errorMsg, fieldNumber: 2)
      }
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_Rejection) -> Bool {
    return withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
      if _storage !== other_storage {
        if _storage._tx != other_storage._tx {return false}
        if _storage._errorMsg != other_storage._errorMsg {return false}
      }
      return true
    }
  }
}

///  ---------- producer events ---------
struct Protos_Unregister: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Unregister"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
  ]

  var events: [Protos_Interest] = []

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeRepeatedMessageField(value: &events)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !events.isEmpty {
      try visitor.visitRepeatedMessageField(value: events, fieldNumber: 1)
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_Unregister) -> Bool {
    if events != other.events {return false}
    return true
  }
}

///   SignedEvent is used for any communication between consumer and producer
struct Protos_SignedEvent: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SignedEvent"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
    2: .same(proto: "eventBytes"),
  ]

  ///   Signature over the event bytes
  var signature: Data = Data()

  ///   Marshal of Event object
  var eventBytes: Data = Data()

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularBytesField(value: &signature)
    case 2: try decoder.decodeSingularBytesField(value: &eventBytes)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !signature.isEmpty {
      try visitor.visitSingularBytesField(value: signature, fieldNumber: 1)
    }
    if !eventBytes.isEmpty {
      try visitor.visitSingularBytesField(value: eventBytes, fieldNumber: 2)
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_SignedEvent) -> Bool {
    if signature != other.signature {return false}
    if eventBytes != other.eventBytes {return false}
    return true
  }
}

///  Event is used by
///    - consumers (adapters) to send Register
///    - producer to advertise supported types and events
struct Protos_Event: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Event"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "register"),
    2: .same(proto: "block"),
    3: .unique(proto: "chaincode_event", json: "chaincodeEvent"),
    4: .same(proto: "rejection"),
    5: .same(proto: "unregister"),
    6: .same(proto: "creator"),
  ]

  private class _StorageClass {
    var _event: Protos_Event.OneOf_Event?
    var _creator: Data = Data()

    init() {}

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._event = _event
      clone._creator = _creator
      return clone
    }
  }

  private var _storage = _StorageClass()

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }

  ///  Register consumer sent event
  var register: Protos_Register {
    get {
      if case .register(let v)? = _storage._event {
        return v
      }
      return Protos_Register()
    }
    set {
      _uniqueStorage()._event = .register(newValue)
    }
  }

  ///  producer events
  var block: Common_Block {
    get {
      if case .block(let v)? = _storage._event {
        return v
      }
      return Common_Block()
    }
    set {
      _uniqueStorage()._event = .block(newValue)
    }
  }

  var chaincodeEvent: Protos_ChaincodeEvent {
    get {
      if case .chaincodeEvent(let v)? = _storage._event {
        return v
      }
      return Protos_ChaincodeEvent()
    }
    set {
      _uniqueStorage()._event = .chaincodeEvent(newValue)
    }
  }

  var rejection: Protos_Rejection {
    get {
      if case .rejection(let v)? = _storage._event {
        return v
      }
      return Protos_Rejection()
    }
    set {
      _uniqueStorage()._event = .rejection(newValue)
    }
  }

  ///  Unregister consumer sent events
  var unregister: Protos_Unregister {
    get {
      if case .unregister(let v)? = _storage._event {
        return v
      }
      return Protos_Unregister()
    }
    set {
      _uniqueStorage()._event = .unregister(newValue)
    }
  }

  ///   Creator of the event, specified as a certificate chain
  var creator: Data {
    get {return _storage._creator}
    set {_uniqueStorage()._creator = newValue}
  }

  var event: OneOf_Event? {
    get {return _storage._event}
    set {
      _uniqueStorage()._event = newValue
    }
  }

  enum OneOf_Event: Equatable {
    case register(Protos_Register)
    case block(Common_Block)
    case chaincodeEvent(Protos_ChaincodeEvent)
    case rejection(Protos_Rejection)
    case unregister(Protos_Unregister)

    static func ==(lhs: Protos_Event.OneOf_Event, rhs: Protos_Event.OneOf_Event) -> Bool {
      switch (lhs, rhs) {
      case (.register(let l), .register(let r)): return l == r
      case (.block(let l), .block(let r)): return l == r
      case (.chaincodeEvent(let l), .chaincodeEvent(let r)): return l == r
      case (.rejection(let l), .rejection(let r)): return l == r
      case (.unregister(let l), .unregister(let r)): return l == r
      default: return false
      }
    }

    fileprivate init?<T: SwiftProtobuf.Decoder>(byDecodingFrom decoder: inout T, fieldNumber: Int) throws {
      switch fieldNumber {
      case 1:
        var value: Protos_Register?
        try decoder.decodeSingularMessageField(value: &value)
        if let value = value {
          self = .register(value)
          return
        }
      case 2:
        var value: Common_Block?
        try decoder.decodeSingularMessageField(value: &value)
        if let value = value {
          self = .block(value)
          return
        }
      case 3:
        var value: Protos_ChaincodeEvent?
        try decoder.decodeSingularMessageField(value: &value)
        if let value = value {
          self = .chaincodeEvent(value)
          return
        }
      case 4:
        var value: Protos_Rejection?
        try decoder.decodeSingularMessageField(value: &value)
        if let value = value {
          self = .rejection(value)
          return
        }
      case 5:
        var value: Protos_Unregister?
        try decoder.decodeSingularMessageField(value: &value)
        if let value = value {
          self = .unregister(value)
          return
        }
      default:
        break
      }
      return nil
    }

    fileprivate func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V, start: Int, end: Int) throws {
      switch self {
      case .register(let v):
        if start <= 1 && 1 < end {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
      case .block(let v):
        if start <= 2 && 2 < end {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }
      case .chaincodeEvent(let v):
        if start <= 3 && 3 < end {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        }
      case .rejection(let v):
        if start <= 4 && 4 < end {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        }
      case .unregister(let v):
        if start <= 5 && 5 < end {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        }
      }
    }
  }

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
      }
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1, 2, 3, 4, 5:
      if _storage._event != nil {
        try decoder.handleConflictingOneOf()
      }
      _storage._event = try Protos_Event.OneOf_Event(byDecodingFrom: &decoder, fieldNumber: fieldNumber)
    case 6: try decoder.decodeSingularBytesField(value: &_storage._creator)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      try _storage._event?.traverse(visitor: &visitor, start: 1, end: 6)
      if !_storage._creator.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._creator, fieldNumber: 6)
      }
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_Event) -> Bool {
    return withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
      if _storage !== other_storage {
        if _storage._event != other_storage._event {return false}
        if _storage._creator != other_storage._creator {return false}
      }
      return true
    }
  }
}

/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: peer/chaincode.proto
 *
 */

// 
// Copyright IBM Corp. 2016 All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _1: SwiftProtobuf.ProtobufAPIVersion_1 {}
  typealias Version = _1
}

///   Confidentiality Levels
enum Protos_ConfidentialityLevel: SwiftProtobuf.Enum, SwiftProtobuf._ProtoNameProviding {
  typealias RawValue = Int
  case `public` // = 0
  case confidential // = 1
  case UNRECOGNIZED(Int)

  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PUBLIC"),
    1: .same(proto: "CONFIDENTIAL"),
  ]

  init() {
    self = .`public`
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .`public`
    case 1: self = .confidential
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .`public`: return 0
    case .confidential: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

///  ChaincodeID contains the path as specified by the deploy transaction
///  that created it as well as the hashCode that is generated by the
///  system for the path. From the user level (ie, CLI, REST API and so on)
///  deploy transaction is expected to provide the path and other requests
///  are expected to provide the hashCode. The other value will be ignored.
///  Internally, the structure could contain both values. For instance, the
///  hashCode will be set when first generated using the path
struct Protos_ChaincodeID: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChaincodeID"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "name"),
    3: .same(proto: "version"),
  ]

  ///  deploy transaction will use the path
  var path: String = ""

  ///  all other requests will use the name (really a hashcode) generated by
  ///  the deploy transaction
  var name: String = ""

  ///  user friendly version name for the chaincode
  var version: String = ""

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularStringField(value: &path)
    case 2: try decoder.decodeSingularStringField(value: &name)
    case 3: try decoder.decodeSingularStringField(value: &version)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !path.isEmpty {
      try visitor.visitSingularStringField(value: path, fieldNumber: 1)
    }
    if !name.isEmpty {
      try visitor.visitSingularStringField(value: name, fieldNumber: 2)
    }
    if !version.isEmpty {
      try visitor.visitSingularStringField(value: version, fieldNumber: 3)
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_ChaincodeID) -> Bool {
    if path != other.path {return false}
    if name != other.name {return false}
    if version != other.version {return false}
    return true
  }
}

///   Carries the chaincode function and its arguments.
///   UnmarshalJSON in transaction.go converts the string-based REST/JSON input to
///   the []byte-based current ChaincodeInput structure.
struct Protos_ChaincodeInput: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChaincodeInput"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "args"),
  ]

  var args: [Data] = []

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeRepeatedBytesField(value: &args)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !args.isEmpty {
      try visitor.visitRepeatedBytesField(value: args, fieldNumber: 1)
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_ChaincodeInput) -> Bool {
    if args != other.args {return false}
    return true
  }
}

///   Carries the chaincode specification. This is the actual metadata required for
///   defining a chaincode.
struct Protos_ChaincodeSpec: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChaincodeSpec"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .unique(proto: "chaincode_id", json: "chaincodeId"),
    3: .same(proto: "input"),
    4: .same(proto: "timeout"),
  ]

  private class _StorageClass {
    var _type: Protos_ChaincodeSpec.TypeEnum = Protos_ChaincodeSpec.TypeEnum.undefined
    var _chaincodeId: Protos_ChaincodeID? = nil
    var _input: Protos_ChaincodeInput? = nil
    var _timeout: Int32 = 0

    init() {}

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._type = _type
      clone._chaincodeId = _chaincodeId
      clone._input = _input
      clone._timeout = _timeout
      return clone
    }
  }

  private var _storage = _StorageClass()

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }

  var type: Protos_ChaincodeSpec.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var chaincodeId: Protos_ChaincodeID {
    get {return _storage._chaincodeId ?? Protos_ChaincodeID()}
    set {_uniqueStorage()._chaincodeId = newValue}
  }
  var hasChaincodeId: Bool {
    return _storage._chaincodeId != nil
  }
  mutating func clearChaincodeId() {
    return _storage._chaincodeId = nil
  }

  var input: Protos_ChaincodeInput {
    get {return _storage._input ?? Protos_ChaincodeInput()}
    set {_uniqueStorage()._input = newValue}
  }
  var hasInput: Bool {
    return _storage._input != nil
  }
  mutating func clearInput() {
    return _storage._input = nil
  }

  var timeout: Int32 {
    get {return _storage._timeout}
    set {_uniqueStorage()._timeout = newValue}
  }

  enum TypeEnum: SwiftProtobuf.Enum, SwiftProtobuf._ProtoNameProviding {
    typealias RawValue = Int
    case undefined // = 0
    case golang // = 1
    case node // = 2
    case car // = 3
    case java // = 4
    case UNRECOGNIZED(Int)

    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
      0: .same(proto: "UNDEFINED"),
      1: .same(proto: "GOLANG"),
      2: .same(proto: "NODE"),
      3: .same(proto: "CAR"),
      4: .same(proto: "JAVA"),
    ]

    init() {
      self = .undefined
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .undefined
      case 1: self = .golang
      case 2: self = .node
      case 3: self = .car
      case 4: self = .java
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .undefined: return 0
      case .golang: return 1
      case .node: return 2
      case .car: return 3
      case .java: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
      }
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
    case 2: try decoder.decodeSingularMessageField(value: &_storage._chaincodeId)
    case 3: try decoder.decodeSingularMessageField(value: &_storage._input)
    case 4: try decoder.decodeSingularInt32Field(value: &_storage._timeout)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != Protos_ChaincodeSpec.TypeEnum.undefined {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if let v = _storage._chaincodeId {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._timeout != 0 {
        try visitor.visitSingularInt32Field(value: _storage._timeout, fieldNumber: 4)
      }
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_ChaincodeSpec) -> Bool {
    return withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
      if _storage !== other_storage {
        if _storage._type != other_storage._type {return false}
        if _storage._chaincodeId != other_storage._chaincodeId {return false}
        if _storage._input != other_storage._input {return false}
        if _storage._timeout != other_storage._timeout {return false}
      }
      return true
    }
  }
}

///   Specify the deployment of a chaincode.
///   TODO: Define `codePackage`.
struct Protos_ChaincodeDeploymentSpec: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChaincodeDeploymentSpec"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "chaincode_spec", json: "chaincodeSpec"),
    2: .unique(proto: "effective_date", json: "effectiveDate"),
    3: .unique(proto: "code_package", json: "codePackage"),
    4: .unique(proto: "exec_env", json: "execEnv"),
  ]

  private class _StorageClass {
    var _chaincodeSpec: Protos_ChaincodeSpec? = nil
    var _effectiveDate: Google_Protobuf_Timestamp? = nil
    var _codePackage: Data = Data()
    var _execEnv: Protos_ChaincodeDeploymentSpec.ExecutionEnvironment = Protos_ChaincodeDeploymentSpec.ExecutionEnvironment.docker

    init() {}

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._chaincodeSpec = _chaincodeSpec
      clone._effectiveDate = _effectiveDate
      clone._codePackage = _codePackage
      clone._execEnv = _execEnv
      return clone
    }
  }

  private var _storage = _StorageClass()

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }

  var chaincodeSpec: Protos_ChaincodeSpec {
    get {return _storage._chaincodeSpec ?? Protos_ChaincodeSpec()}
    set {_uniqueStorage()._chaincodeSpec = newValue}
  }
  var hasChaincodeSpec: Bool {
    return _storage._chaincodeSpec != nil
  }
  mutating func clearChaincodeSpec() {
    return _storage._chaincodeSpec = nil
  }

  ///   Controls when the chaincode becomes executable.
  var effectiveDate: Google_Protobuf_Timestamp {
    get {return _storage._effectiveDate ?? Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._effectiveDate = newValue}
  }
  var hasEffectiveDate: Bool {
    return _storage._effectiveDate != nil
  }
  mutating func clearEffectiveDate() {
    return _storage._effectiveDate = nil
  }

  var codePackage: Data {
    get {return _storage._codePackage}
    set {_uniqueStorage()._codePackage = newValue}
  }

  var execEnv: Protos_ChaincodeDeploymentSpec.ExecutionEnvironment {
    get {return _storage._execEnv}
    set {_uniqueStorage()._execEnv = newValue}
  }

  enum ExecutionEnvironment: SwiftProtobuf.Enum, SwiftProtobuf._ProtoNameProviding {
    typealias RawValue = Int
    case docker // = 0
    case system // = 1
    case UNRECOGNIZED(Int)

    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
      0: .same(proto: "DOCKER"),
      1: .same(proto: "SYSTEM"),
    ]

    init() {
      self = .docker
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .docker
      case 1: self = .system
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .docker: return 0
      case .system: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
      }
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularMessageField(value: &_storage._chaincodeSpec)
    case 2: try decoder.decodeSingularMessageField(value: &_storage._effectiveDate)
    case 3: try decoder.decodeSingularBytesField(value: &_storage._codePackage)
    case 4: try decoder.decodeSingularEnumField(value: &_storage._execEnv)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._chaincodeSpec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._effectiveDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._codePackage.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._codePackage, fieldNumber: 3)
      }
      if _storage._execEnv != Protos_ChaincodeDeploymentSpec.ExecutionEnvironment.docker {
        try visitor.visitSingularEnumField(value: _storage._execEnv, fieldNumber: 4)
      }
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_ChaincodeDeploymentSpec) -> Bool {
    return withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
      if _storage !== other_storage {
        if _storage._chaincodeSpec != other_storage._chaincodeSpec {return false}
        if _storage._effectiveDate != other_storage._effectiveDate {return false}
        if _storage._codePackage != other_storage._codePackage {return false}
        if _storage._execEnv != other_storage._execEnv {return false}
      }
      return true
    }
  }
}

///   Carries the chaincode function and its arguments.
struct Protos_ChaincodeInvocationSpec: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChaincodeInvocationSpec"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "chaincode_spec", json: "chaincodeSpec"),
    2: .unique(proto: "id_generation_alg", json: "idGenerationAlg"),
  ]

  private class _StorageClass {
    var _chaincodeSpec: Protos_ChaincodeSpec? = nil
    var _idGenerationAlg: String = ""

    init() {}

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._chaincodeSpec = _chaincodeSpec
      clone._idGenerationAlg = _idGenerationAlg
      return clone
    }
  }

  private var _storage = _StorageClass()

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }

  var chaincodeSpec: Protos_ChaincodeSpec {
    get {return _storage._chaincodeSpec ?? Protos_ChaincodeSpec()}
    set {_uniqueStorage()._chaincodeSpec = newValue}
  }
  var hasChaincodeSpec: Bool {
    return _storage._chaincodeSpec != nil
  }
  mutating func clearChaincodeSpec() {
    return _storage._chaincodeSpec = nil
  }

  ///   This field can contain a user-specified ID generation algorithm
  ///   If supplied, this will be used to generate a ID
  ///   If not supplied (left empty), sha256base64 will be used
  ///   The algorithm consists of two parts:
  ///    1, a hash function
  ///    2, a decoding used to decode user (string) input to bytes
  ///   Currently, SHA256 with BASE64 is supported (e.g. idGenerationAlg='sha256base64')
  var idGenerationAlg: String {
    get {return _storage._idGenerationAlg}
    set {_uniqueStorage()._idGenerationAlg = newValue}
  }

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
      }
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularMessageField(value: &_storage._chaincodeSpec)
    case 2: try decoder.decodeSingularStringField(value: &_storage._idGenerationAlg)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._chaincodeSpec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._idGenerationAlg.isEmpty {
        try visitor.visitSingularStringField(value: _storage._idGenerationAlg, fieldNumber: 2)
      }
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_ChaincodeInvocationSpec) -> Bool {
    return withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
      if _storage !== other_storage {
        if _storage._chaincodeSpec != other_storage._chaincodeSpec {return false}
        if _storage._idGenerationAlg != other_storage._idGenerationAlg {return false}
      }
      return true
    }
  }
}

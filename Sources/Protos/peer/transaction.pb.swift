/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: peer/transaction.proto
 *
 */

// 
// Copyright IBM Corp. 2016 All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf


///   This message is necessary to facilitate the verification of the signature
///   (in the signature field) over the bytes of the transaction (in the
///   transactionBytes field).
struct Protos_SignedTransaction: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Protos_SignedTransaction"}
  public var protoMessageName: String {return "SignedTransaction"}
  public var protoPackageName: String {return "protos"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .unique(proto: "transaction_bytes", json: "transactionBytes", swift: "transactionBytes"),
    2: .same(proto: "signature", swift: "signature"),
  ]


  ///   The bytes of the Transaction. NDD
  var transactionBytes: Data = Data()

  ///   Signature of the transactionBytes The public key of the signature is in
  ///   the header field of TransactionAction There might be multiple
  ///   TransactionAction, so multiple headers, but there should be same
  ///   transactor identity (cert) in all headers
  var signature: Data = Data()

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &transactionBytes)
    case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &signature)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if transactionBytes != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: transactionBytes, fieldNumber: 1)
    }
    if signature != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: signature, fieldNumber: 2)
    }
  }

  public func _protoc_generated_isEqualTo(other: Protos_SignedTransaction) -> Bool {
    if transactionBytes != other.transactionBytes {return false}
    if signature != other.signature {return false}
    return true
  }
}

///   ProcessedTransaction wraps an Envelope that includes a transaction along with an indication
///   of whether the transaction was validated or invalidated by committing peer.
///   The use case is that GetTransactionByID API needs to retrieve the transaction Envelope
///   from block storage, and return it to a client, and indicate whether the transaction
///   was validated or invalidated by committing peer. So that the originally submitted
///   transaction Envelope is not modified, the ProcessedTransaction wrapper is returned.
struct Protos_ProcessedTransaction: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Protos_ProcessedTransaction"}
  public var protoMessageName: String {return "ProcessedTransaction"}
  public var protoPackageName: String {return "protos"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "transactionEnvelope", swift: "transactionEnvelope"),
    2: .same(proto: "valid", swift: "valid"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Protos_ProcessedTransaction
    var _transactionEnvelope: Common_Envelope? = nil
    var _valid: Bool = false

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularMessageField(fieldType: Common_Envelope.self, value: &_transactionEnvelope)
      case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: &_valid)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if let v = _transactionEnvelope {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _valid != false {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBool.self, value: _valid, fieldNumber: 2)
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _transactionEnvelope != other._transactionEnvelope {return false}
      if _valid != other._valid {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._transactionEnvelope = _transactionEnvelope
      clone._valid = _valid
      return clone
    }
  }

  private var _storage = _StorageClass()


  ///   An Envelope which includes a processed transaction
  var transactionEnvelope: Common_Envelope {
    get {return _storage._transactionEnvelope ?? Common_Envelope()}
    set {_uniqueStorage()._transactionEnvelope = newValue}
  }
  public var hasTransactionEnvelope: Bool {
    return _storage._transactionEnvelope != nil
  }
  public mutating func clearTransactionEnvelope() {
    return _storage._transactionEnvelope = nil
  }

  ///   An indication of whether the transaction was validated or invalidated by committing peer
  var valid: Bool {
    get {return _storage._valid}
    set {_uniqueStorage()._valid = newValue}
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Protos_ProcessedTransaction) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   The transaction to be sent to the ordering service. A transaction contains
///   one or more TransactionAction. Each TransactionAction binds a proposal to
///   potentially multiple actions. The transaction is atomic meaning that either
///   all actions in the transaction will be committed or none will.  Note that
///   while a Transaction might include more than one Header, the Header.creator
///   field must be the same in each.
///   A single client is free to issue a number of independent Proposal, each with
///   their header (Header) and request payload (ChaincodeProposalPayload).  Each
///   proposal is independently endorsed generating an action
///   (ProposalResponsePayload) with one signature per Endorser. Any number of
///   independent proposals (and their action) might be included in a transaction
///   to ensure that they are treated atomically.
struct Protos_Transaction: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Protos_Transaction"}
  public var protoMessageName: String {return "Transaction"}
  public var protoPackageName: String {return "protos"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "actions", swift: "actions"),
  ]


  ///   The payload is an array of TransactionAction. An array is necessary to
  ///   accommodate multiple actions per transaction
  var actions: [Protos_TransactionAction] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeRepeatedMessageField(fieldType: Protos_TransactionAction.self, value: &actions)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if !actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: actions, fieldNumber: 1)
    }
  }

  public func _protoc_generated_isEqualTo(other: Protos_Transaction) -> Bool {
    if actions != other.actions {return false}
    return true
  }
}

///   TransactionAction binds a proposal to its action.  The type field in the
///   header dictates the type of action to be applied to the ledger.
struct Protos_TransactionAction: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Protos_TransactionAction"}
  public var protoMessageName: String {return "TransactionAction"}
  public var protoPackageName: String {return "protos"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "header", swift: "header"),
    2: .same(proto: "payload", swift: "payload"),
  ]


  ///   The header of the proposal action, which is the proposal header
  var header: Data = Data()

  ///   The payload of the action as defined by the type in the header For
  ///   chaincode, it's the bytes of ChaincodeActionPayload
  var payload: Data = Data()

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &header)
    case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &payload)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if header != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: header, fieldNumber: 1)
    }
    if payload != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: payload, fieldNumber: 2)
    }
  }

  public func _protoc_generated_isEqualTo(other: Protos_TransactionAction) -> Bool {
    if header != other.header {return false}
    if payload != other.payload {return false}
    return true
  }
}

// ---------- Chaincode Transaction ------------

///   ChaincodeActionPayload is the message to be used for the TransactionAction's
///   payload when the Header's type is set to CHAINCODE.  It carries the
///   chaincodeProposalPayload and an endorsed action to apply to the ledger.
struct Protos_ChaincodeActionPayload: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Protos_ChaincodeActionPayload"}
  public var protoMessageName: String {return "ChaincodeActionPayload"}
  public var protoPackageName: String {return "protos"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .unique(proto: "chaincode_proposal_payload", json: "chaincodeProposalPayload", swift: "chaincodeProposalPayload"),
    2: .same(proto: "action", swift: "action"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Protos_ChaincodeActionPayload
    var _chaincodeProposalPayload: Data = Data()
    var _action: Protos_ChaincodeEndorsedAction? = nil

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &_chaincodeProposalPayload)
      case 2: try setter.decodeSingularMessageField(fieldType: Protos_ChaincodeEndorsedAction.self, value: &_action)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if _chaincodeProposalPayload != Data() {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: _chaincodeProposalPayload, fieldNumber: 1)
      }
      if let v = _action {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _chaincodeProposalPayload != other._chaincodeProposalPayload {return false}
      if _action != other._action {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._chaincodeProposalPayload = _chaincodeProposalPayload
      clone._action = _action
      return clone
    }
  }

  private var _storage = _StorageClass()


  ///   This field contains the bytes of the ChaincodeProposalPayload message from
  ///   the original invocation (essentially the arguments) after the application
  ///   of the visibility function. The main visibility modes are "full" (the
  ///   entire ChaincodeProposalPayload message is included here), "hash" (only
  ///   the hash of the ChaincodeProposalPayload message is included) or
  ///   "nothing".  This field will be used to check the consistency of
  ///   ProposalResponsePayload.proposalHash.  For the CHAINCODE type,
  ///   ProposalResponsePayload.proposalHash is supposed to be H(ProposalHeader ||
  ///   f(ChaincodeProposalPayload)) where f is the visibility function.
  var chaincodeProposalPayload: Data {
    get {return _storage._chaincodeProposalPayload}
    set {_uniqueStorage()._chaincodeProposalPayload = newValue}
  }

  ///   The list of actions to apply to the ledger
  var action: Protos_ChaincodeEndorsedAction {
    get {return _storage._action ?? Protos_ChaincodeEndorsedAction()}
    set {_uniqueStorage()._action = newValue}
  }
  public var hasAction: Bool {
    return _storage._action != nil
  }
  public mutating func clearAction() {
    return _storage._action = nil
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Protos_ChaincodeActionPayload) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   ChaincodeEndorsedAction carries information about the endorsement of a
///   specific proposal
struct Protos_ChaincodeEndorsedAction: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Protos_ChaincodeEndorsedAction"}
  public var protoMessageName: String {return "ChaincodeEndorsedAction"}
  public var protoPackageName: String {return "protos"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .unique(proto: "proposal_response_payload", json: "proposalResponsePayload", swift: "proposalResponsePayload"),
    2: .same(proto: "endorsements", swift: "endorsements"),
  ]


  ///   This is the bytes of the ProposalResponsePayload message signed by the
  ///   endorsers.  Recall that for the CHAINCODE type, the
  ///   ProposalResponsePayload's extenstion field carries a ChaincodeAction
  var proposalResponsePayload: Data = Data()

  ///   The endorsement of the proposal, basically the endorser's signature over
  ///   proposalResponsePayload
  var endorsements: [Protos_Endorsement] = []

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &proposalResponsePayload)
    case 2: try setter.decodeRepeatedMessageField(fieldType: Protos_Endorsement.self, value: &endorsements)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if proposalResponsePayload != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: proposalResponsePayload, fieldNumber: 1)
    }
    if !endorsements.isEmpty {
      try visitor.visitRepeatedMessageField(value: endorsements, fieldNumber: 2)
    }
  }

  public func _protoc_generated_isEqualTo(other: Protos_ChaincodeEndorsedAction) -> Bool {
    if proposalResponsePayload != other.proposalResponsePayload {return false}
    if endorsements != other.endorsements {return false}
    return true
  }
}

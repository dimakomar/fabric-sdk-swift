/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: peer/transaction.proto
 *
 */

// 
// Copyright IBM Corp. 2016 All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _1: SwiftProtobuf.ProtobufAPIVersion_1 {}
  typealias Version = _1
}

enum Protos_TxValidationCode: SwiftProtobuf.Enum, SwiftProtobuf._ProtoNameProviding {
  typealias RawValue = Int
  case valid // = 0
  case nilEnvelope // = 1
  case badPayload // = 2
  case badCommonHeader // = 3
  case badCreatorSignature // = 4
  case invalidEndorserTransaction // = 5
  case invalidConfigTransaction // = 6
  case unsupportedTxPayload // = 7
  case badProposalTxid // = 8
  case duplicateTxid // = 9
  case endorsementPolicyFailure // = 10
  case mvccReadConflict // = 11
  case phantomReadConflict // = 12
  case unknownTxType // = 13
  case targetChainNotFound // = 14
  case marshalTxError // = 15
  case nilTxaction // = 16
  case invalidOtherReason // = 255
  case UNRECOGNIZED(Int)

  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VALID"),
    1: .same(proto: "NIL_ENVELOPE"),
    2: .same(proto: "BAD_PAYLOAD"),
    3: .same(proto: "BAD_COMMON_HEADER"),
    4: .same(proto: "BAD_CREATOR_SIGNATURE"),
    5: .same(proto: "INVALID_ENDORSER_TRANSACTION"),
    6: .same(proto: "INVALID_CONFIG_TRANSACTION"),
    7: .same(proto: "UNSUPPORTED_TX_PAYLOAD"),
    8: .same(proto: "BAD_PROPOSAL_TXID"),
    9: .same(proto: "DUPLICATE_TXID"),
    10: .same(proto: "ENDORSEMENT_POLICY_FAILURE"),
    11: .same(proto: "MVCC_READ_CONFLICT"),
    12: .same(proto: "PHANTOM_READ_CONFLICT"),
    13: .same(proto: "UNKNOWN_TX_TYPE"),
    14: .same(proto: "TARGET_CHAIN_NOT_FOUND"),
    15: .same(proto: "MARSHAL_TX_ERROR"),
    16: .same(proto: "NIL_TXACTION"),
    255: .same(proto: "INVALID_OTHER_REASON"),
  ]

  init() {
    self = .valid
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .valid
    case 1: self = .nilEnvelope
    case 2: self = .badPayload
    case 3: self = .badCommonHeader
    case 4: self = .badCreatorSignature
    case 5: self = .invalidEndorserTransaction
    case 6: self = .invalidConfigTransaction
    case 7: self = .unsupportedTxPayload
    case 8: self = .badProposalTxid
    case 9: self = .duplicateTxid
    case 10: self = .endorsementPolicyFailure
    case 11: self = .mvccReadConflict
    case 12: self = .phantomReadConflict
    case 13: self = .unknownTxType
    case 14: self = .targetChainNotFound
    case 15: self = .marshalTxError
    case 16: self = .nilTxaction
    case 255: self = .invalidOtherReason
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .valid: return 0
    case .nilEnvelope: return 1
    case .badPayload: return 2
    case .badCommonHeader: return 3
    case .badCreatorSignature: return 4
    case .invalidEndorserTransaction: return 5
    case .invalidConfigTransaction: return 6
    case .unsupportedTxPayload: return 7
    case .badProposalTxid: return 8
    case .duplicateTxid: return 9
    case .endorsementPolicyFailure: return 10
    case .mvccReadConflict: return 11
    case .phantomReadConflict: return 12
    case .unknownTxType: return 13
    case .targetChainNotFound: return 14
    case .marshalTxError: return 15
    case .nilTxaction: return 16
    case .invalidOtherReason: return 255
    case .UNRECOGNIZED(let i): return i
    }
  }

}

///   This message is necessary to facilitate the verification of the signature
///   (in the signature field) over the bytes of the transaction (in the
///   transactionBytes field).
struct Protos_SignedTransaction: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SignedTransaction"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "transaction_bytes", json: "transactionBytes"),
    2: .same(proto: "signature"),
  ]

  ///   The bytes of the Transaction. NDD
  var transactionBytes: Data = Data()

  ///   Signature of the transactionBytes The public key of the signature is in
  ///   the header field of TransactionAction There might be multiple
  ///   TransactionAction, so multiple headers, but there should be same
  ///   transactor identity (cert) in all headers
  var signature: Data = Data()

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularBytesField(value: &transactionBytes)
    case 2: try decoder.decodeSingularBytesField(value: &signature)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !transactionBytes.isEmpty {
      try visitor.visitSingularBytesField(value: transactionBytes, fieldNumber: 1)
    }
    if !signature.isEmpty {
      try visitor.visitSingularBytesField(value: signature, fieldNumber: 2)
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_SignedTransaction) -> Bool {
    if transactionBytes != other.transactionBytes {return false}
    if signature != other.signature {return false}
    return true
  }
}

///   ProcessedTransaction wraps an Envelope that includes a transaction along with an indication
///   of whether the transaction was validated or invalidated by committing peer.
///   The use case is that GetTransactionByID API needs to retrieve the transaction Envelope
///   from block storage, and return it to a client, and indicate whether the transaction
///   was validated or invalidated by committing peer. So that the originally submitted
///   transaction Envelope is not modified, the ProcessedTransaction wrapper is returned.
struct Protos_ProcessedTransaction: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProcessedTransaction"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionEnvelope"),
    2: .same(proto: "validationCode"),
  ]

  private class _StorageClass {
    var _transactionEnvelope: Common_Envelope? = nil
    var _validationCode: Int32 = 0

    init() {}

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._transactionEnvelope = _transactionEnvelope
      clone._validationCode = _validationCode
      return clone
    }
  }

  private var _storage = _StorageClass()

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }

  ///   An Envelope which includes a processed transaction
  var transactionEnvelope: Common_Envelope {
    get {return _storage._transactionEnvelope ?? Common_Envelope()}
    set {_uniqueStorage()._transactionEnvelope = newValue}
  }
  var hasTransactionEnvelope: Bool {
    return _storage._transactionEnvelope != nil
  }
  mutating func clearTransactionEnvelope() {
    return _storage._transactionEnvelope = nil
  }

  ///   An indication of whether the transaction was validated or invalidated by committing peer
  var validationCode: Int32 {
    get {return _storage._validationCode}
    set {_uniqueStorage()._validationCode = newValue}
  }

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
      }
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularMessageField(value: &_storage._transactionEnvelope)
    case 2: try decoder.decodeSingularInt32Field(value: &_storage._validationCode)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._transactionEnvelope {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._validationCode != 0 {
        try visitor.visitSingularInt32Field(value: _storage._validationCode, fieldNumber: 2)
      }
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_ProcessedTransaction) -> Bool {
    return withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
      if _storage !== other_storage {
        if _storage._transactionEnvelope != other_storage._transactionEnvelope {return false}
        if _storage._validationCode != other_storage._validationCode {return false}
      }
      return true
    }
  }
}

///   The transaction to be sent to the ordering service. A transaction contains
///   one or more TransactionAction. Each TransactionAction binds a proposal to
///   potentially multiple actions. The transaction is atomic meaning that either
///   all actions in the transaction will be committed or none will.  Note that
///   while a Transaction might include more than one Header, the Header.creator
///   field must be the same in each.
///   A single client is free to issue a number of independent Proposal, each with
///   their header (Header) and request payload (ChaincodeProposalPayload).  Each
///   proposal is independently endorsed generating an action
///   (ProposalResponsePayload) with one signature per Endorser. Any number of
///   independent proposals (and their action) might be included in a transaction
///   to ensure that they are treated atomically.
struct Protos_Transaction: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Transaction"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actions"),
  ]

  ///   The payload is an array of TransactionAction. An array is necessary to
  ///   accommodate multiple actions per transaction
  var actions: [Protos_TransactionAction] = []

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeRepeatedMessageField(value: &actions)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: actions, fieldNumber: 1)
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_Transaction) -> Bool {
    if actions != other.actions {return false}
    return true
  }
}

///   TransactionAction binds a proposal to its action.  The type field in the
///   header dictates the type of action to be applied to the ledger.
struct Protos_TransactionAction: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TransactionAction"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "payload"),
  ]

  ///   The header of the proposal action, which is the proposal header
  var header: Data = Data()

  ///   The payload of the action as defined by the type in the header For
  ///   chaincode, it's the bytes of ChaincodeActionPayload
  var payload: Data = Data()

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularBytesField(value: &header)
    case 2: try decoder.decodeSingularBytesField(value: &payload)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !header.isEmpty {
      try visitor.visitSingularBytesField(value: header, fieldNumber: 1)
    }
    if !payload.isEmpty {
      try visitor.visitSingularBytesField(value: payload, fieldNumber: 2)
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_TransactionAction) -> Bool {
    if header != other.header {return false}
    if payload != other.payload {return false}
    return true
  }
}

// ---------- Chaincode Transaction ------------

///   ChaincodeActionPayload is the message to be used for the TransactionAction's
///   payload when the Header's type is set to CHAINCODE.  It carries the
///   chaincodeProposalPayload and an endorsed action to apply to the ledger.
struct Protos_ChaincodeActionPayload: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChaincodeActionPayload"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "chaincode_proposal_payload", json: "chaincodeProposalPayload"),
    2: .same(proto: "action"),
  ]

  private class _StorageClass {
    var _chaincodeProposalPayload: Data = Data()
    var _action: Protos_ChaincodeEndorsedAction? = nil

    init() {}

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._chaincodeProposalPayload = _chaincodeProposalPayload
      clone._action = _action
      return clone
    }
  }

  private var _storage = _StorageClass()

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }

  ///   This field contains the bytes of the ChaincodeProposalPayload message from
  ///   the original invocation (essentially the arguments) after the application
  ///   of the visibility function. The main visibility modes are "full" (the
  ///   entire ChaincodeProposalPayload message is included here), "hash" (only
  ///   the hash of the ChaincodeProposalPayload message is included) or
  ///   "nothing".  This field will be used to check the consistency of
  ///   ProposalResponsePayload.proposalHash.  For the CHAINCODE type,
  ///   ProposalResponsePayload.proposalHash is supposed to be H(ProposalHeader ||
  ///   f(ChaincodeProposalPayload)) where f is the visibility function.
  var chaincodeProposalPayload: Data {
    get {return _storage._chaincodeProposalPayload}
    set {_uniqueStorage()._chaincodeProposalPayload = newValue}
  }

  ///   The list of actions to apply to the ledger
  var action: Protos_ChaincodeEndorsedAction {
    get {return _storage._action ?? Protos_ChaincodeEndorsedAction()}
    set {_uniqueStorage()._action = newValue}
  }
  var hasAction: Bool {
    return _storage._action != nil
  }
  mutating func clearAction() {
    return _storage._action = nil
  }

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
      }
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularBytesField(value: &_storage._chaincodeProposalPayload)
    case 2: try decoder.decodeSingularMessageField(value: &_storage._action)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._chaincodeProposalPayload.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._chaincodeProposalPayload, fieldNumber: 1)
      }
      if let v = _storage._action {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_ChaincodeActionPayload) -> Bool {
    return withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
      if _storage !== other_storage {
        if _storage._chaincodeProposalPayload != other_storage._chaincodeProposalPayload {return false}
        if _storage._action != other_storage._action {return false}
      }
      return true
    }
  }
}

///   ChaincodeEndorsedAction carries information about the endorsement of a
///   specific proposal
struct Protos_ChaincodeEndorsedAction: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChaincodeEndorsedAction"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "proposal_response_payload", json: "proposalResponsePayload"),
    2: .same(proto: "endorsements"),
  ]

  ///   This is the bytes of the ProposalResponsePayload message signed by the
  ///   endorsers.  Recall that for the CHAINCODE type, the
  ///   ProposalResponsePayload's extenstion field carries a ChaincodeAction
  var proposalResponsePayload: Data = Data()

  ///   The endorsement of the proposal, basically the endorser's signature over
  ///   proposalResponsePayload
  var endorsements: [Protos_Endorsement] = []

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularBytesField(value: &proposalResponsePayload)
    case 2: try decoder.decodeRepeatedMessageField(value: &endorsements)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !proposalResponsePayload.isEmpty {
      try visitor.visitSingularBytesField(value: proposalResponsePayload, fieldNumber: 1)
    }
    if !endorsements.isEmpty {
      try visitor.visitRepeatedMessageField(value: endorsements, fieldNumber: 2)
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_ChaincodeEndorsedAction) -> Bool {
    if proposalResponsePayload != other.proposalResponsePayload {return false}
    if endorsements != other.endorsements {return false}
    return true
  }
}

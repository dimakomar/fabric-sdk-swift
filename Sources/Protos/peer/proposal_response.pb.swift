/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: peer/proposal_response.proto
 *
 */

// 
// Copyright IBM Corp. 2016 All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf


///   A ProposalResponse is returned from an endorser to the proposal submitter.
///   The idea is that this message contains the endorser's response to the
///   request of a client to perform an action over a chaincode (or more
///   generically on the ledger); the response might be success/error (conveyed in
///   the Response field) together with a description of the action and a
///   signature over it by that endorser.  If a sufficient number of distinct
///   endorsers agree on the same action and produce signature to that effect, a
///   transaction can be generated and sent for ordering.
struct Protos_ProposalResponse: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Protos_ProposalResponse"}
  public var protoMessageName: String {return "ProposalResponse"}
  public var protoPackageName: String {return "protos"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "version", swift: "version"),
    2: .same(proto: "timestamp", swift: "timestamp"),
    4: .same(proto: "response", swift: "response"),
    5: .same(proto: "payload", swift: "payload"),
    6: .same(proto: "endorsement", swift: "endorsement"),
  ]

  private class _StorageClass {
    typealias ExtendedMessage = Protos_ProposalResponse
    var _version: Int32 = 0
    var _timestamp: Google_Protobuf_Timestamp? = nil
    var _response: Protos_Response? = nil
    var _payload: Data = Data()
    var _endorsement: Protos_Endorsement? = nil

    init() {}

    func decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
      switch protoFieldNumber {
      case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &_version)
      case 2: try setter.decodeSingularMessageField(fieldType: Google_Protobuf_Timestamp.self, value: &_timestamp)
      case 4: try setter.decodeSingularMessageField(fieldType: Protos_Response.self, value: &_response)
      case 5: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &_payload)
      case 6: try setter.decodeSingularMessageField(fieldType: Protos_Endorsement.self, value: &_endorsement)
      default: break
      }
    }

    func traverse(visitor: SwiftProtobuf.Visitor) throws {
      if _version != 0 {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: _version, fieldNumber: 1)
      }
      if let v = _timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _response {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _payload != Data() {
        try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: _payload, fieldNumber: 5)
      }
      if let v = _endorsement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _version != other._version {return false}
      if _timestamp != other._timestamp {return false}
      if _response != other._response {return false}
      if _payload != other._payload {return false}
      if _endorsement != other._endorsement {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._version = _version
      clone._timestamp = _timestamp
      clone._response = _response
      clone._payload = _payload
      clone._endorsement = _endorsement
      return clone
    }
  }

  private var _storage = _StorageClass()


  ///   Version indicates message protocol version
  var version: Int32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  ///   Timestamp is the time that the message
  ///   was created as  defined by the sender
  var timestamp: Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  public var hasTimestamp: Bool {
    return _storage._timestamp != nil
  }
  public mutating func clearTimestamp() {
    return _storage._timestamp = nil
  }

  ///   A response message indicating whether the
  ///   endorsement of the action was successful
  var response: Protos_Response {
    get {return _storage._response ?? Protos_Response()}
    set {_uniqueStorage()._response = newValue}
  }
  public var hasResponse: Bool {
    return _storage._response != nil
  }
  public mutating func clearResponse() {
    return _storage._response = nil
  }

  ///   The payload of response. It is the bytes of ProposalResponsePayload
  var payload: Data {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  ///   The endorsement of the proposal, basically
  ///   the endorser's signature over the payload
  var endorsement: Protos_Endorsement {
    get {return _storage._endorsement ?? Protos_Endorsement()}
    set {_uniqueStorage()._endorsement = newValue}
  }
  public var hasEndorsement: Bool {
    return _storage._endorsement != nil
  }
  public mutating func clearEndorsement() {
    return _storage._endorsement = nil
  }

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    try _storage.traverse(visitor: visitor)
  }

  public func _protoc_generated_isEqualTo(other: Protos_ProposalResponse) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   A response with a representation similar to an HTTP response that can
///   be used within another message.
struct Protos_Response: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Protos_Response"}
  public var protoMessageName: String {return "Response"}
  public var protoPackageName: String {return "protos"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "status", swift: "status"),
    2: .same(proto: "message", swift: "message"),
    3: .same(proto: "payload", swift: "payload"),
  ]


  ///   A status code that should follow the HTTP status codes.
  var status: Int32 = 0

  ///   A message associated with the response code.
  var message: String = ""

  ///   A payload that can be used to include metadata with this response.
  var payload: Data = Data()

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: &status)
    case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: &message)
    case 3: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &payload)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if status != 0 {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufInt32.self, value: status, fieldNumber: 1)
    }
    if message != "" {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufString.self, value: message, fieldNumber: 2)
    }
    if payload != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: payload, fieldNumber: 3)
    }
  }

  public func _protoc_generated_isEqualTo(other: Protos_Response) -> Bool {
    if status != other.status {return false}
    if message != other.message {return false}
    if payload != other.payload {return false}
    return true
  }
}

///   ProposalResponsePayload is the payload of a proposal response.  This message
///   is the "bridge" between the client's request and the endorser's action in
///   response to that request. Concretely, for chaincodes, it contains a hashed
///   representation of the proposal (proposalHash) and a representation of the
///   chaincode state changes and events inside the extension field.
struct Protos_ProposalResponsePayload: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Protos_ProposalResponsePayload"}
  public var protoMessageName: String {return "ProposalResponsePayload"}
  public var protoPackageName: String {return "protos"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .unique(proto: "proposal_hash", json: "proposalHash", swift: "proposalHash"),
    2: .same(proto: "extension", swift: "extension_p"),
  ]


  ///   Hash of the proposal that triggered this response. The hash is used to
  ///   link a response with its proposal, both for bookeeping purposes on an
  ///   asynchronous system and for security reasons (accountability,
  ///   non-repudiation). The hash usually covers the entire Proposal message
  ///   (byte-by-byte). However this implies that the hash can only be verified
  ///   if the entire proposal message is available when ProposalResponsePayload is
  ///   included in a transaction or stored in the ledger. For confidentiality
  ///   reasons, with chaincodes it might be undesirable to store the proposal
  ///   payload in the ledger.  If the type is CHAINCODE, this is handled by
  ///   separating the proposal's header and
  ///   the payload: the header is always hashed in its entirety whereas the
  ///   payload can either be hashed fully, or only its hash may be hashed, or
  ///   nothing from the payload can be hashed. The PayloadVisibility field in the
  ///   Header's extension controls to which extent the proposal payload is
  ///   "visible" in the sense that was just explained.
  var proposalHash: Data = Data()

  ///   Extension should be unmarshaled to a type-specific message. The type of
  ///   the extension in any proposal response depends on the type of the proposal
  ///   that the client selected when the proposal was initially sent out.  In
  ///   particular, this information is stored in the type field of a Header.  For
  ///   chaincode, it's a ChaincodeAction message
  var extension_p: Data = Data()

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &proposalHash)
    case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &extension_p)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if proposalHash != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: proposalHash, fieldNumber: 1)
    }
    if extension_p != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: extension_p, fieldNumber: 2)
    }
  }

  public func _protoc_generated_isEqualTo(other: Protos_ProposalResponsePayload) -> Bool {
    if proposalHash != other.proposalHash {return false}
    if extension_p != other.extension_p {return false}
    return true
  }
}

///   An endorsement is a signature of an endorser over a proposal response.  By
///   producing an endorsement message, an endorser implicitly "approves" that
///   proposal response and the actions contained therein. When enough
///   endorsements have been collected, a transaction can be generated out of a
///   set of proposal responses.  Note that this message only contains an identity
///   and a signature but no signed payload. This is intentional because
///   endorsements are supposed to be collected in a transaction, and they are all
///   expected to endorse a single proposal response/action (many endorsements
///   over a single proposal response)
struct Protos_Endorsement: SwiftProtobuf.Message, SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf.ProtoNameProviding {
  public var swiftClassName: String {return "Protos_Endorsement"}
  public var protoMessageName: String {return "Endorsement"}
  public var protoPackageName: String {return "protos"}
  public static let _protobuf_fieldNames: FieldNameMap = [
    1: .same(proto: "endorser", swift: "endorser"),
    2: .same(proto: "signature", swift: "signature"),
  ]


  ///   Identity of the endorser (e.g. its certificate)
  var endorser: Data = Data()

  ///   Signature of the payload included in ProposalResponse concatenated with
  ///   the endorser's certificate; ie, sign(ProposalResponse.payload + endorser)
  var signature: Data = Data()

  init() {}

  public mutating func _protoc_generated_decodeField<T: SwiftProtobuf.FieldDecoder>(setter: inout T, protoFieldNumber: Int) throws {
    switch protoFieldNumber {
    case 1: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &endorser)
    case 2: try setter.decodeSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: &signature)
    default: break
    }
  }

  public func _protoc_generated_traverse(visitor: SwiftProtobuf.Visitor) throws {
    if endorser != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: endorser, fieldNumber: 1)
    }
    if signature != Data() {
      try visitor.visitSingularField(fieldType: SwiftProtobuf.ProtobufBytes.self, value: signature, fieldNumber: 2)
    }
  }

  public func _protoc_generated_isEqualTo(other: Protos_Endorsement) -> Bool {
    if endorser != other.endorser {return false}
    if signature != other.signature {return false}
    return true
  }
}

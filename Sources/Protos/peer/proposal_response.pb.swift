/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: peer/proposal_response.proto
 *
 */

// 
// Copyright IBM Corp. 2016 All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _1: SwiftProtobuf.ProtobufAPIVersion_1 {}
  typealias Version = _1
}

///   A ProposalResponse is returned from an endorser to the proposal submitter.
///   The idea is that this message contains the endorser's response to the
///   request of a client to perform an action over a chaincode (or more
///   generically on the ledger); the response might be success/error (conveyed in
///   the Response field) together with a description of the action and a
///   signature over it by that endorser.  If a sufficient number of distinct
///   endorsers agree on the same action and produce signature to that effect, a
///   transaction can be generated and sent for ordering.
struct Protos_ProposalResponse: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProposalResponse"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "timestamp"),
    4: .same(proto: "response"),
    5: .same(proto: "payload"),
    6: .same(proto: "endorsement"),
  ]

  private class _StorageClass {
    var _version: Int32 = 0
    var _timestamp: Google_Protobuf_Timestamp? = nil
    var _response: Protos_Response? = nil
    var _payload: Data = Data()
    var _endorsement: Protos_Endorsement? = nil

    init() {}

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._version = _version
      clone._timestamp = _timestamp
      clone._response = _response
      clone._payload = _payload
      clone._endorsement = _endorsement
      return clone
    }
  }

  private var _storage = _StorageClass()

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }

  ///   Version indicates message protocol version
  var version: Int32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  ///   Timestamp is the time that the message
  ///   was created as  defined by the sender
  var timestamp: Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  var hasTimestamp: Bool {
    return _storage._timestamp != nil
  }
  mutating func clearTimestamp() {
    return _storage._timestamp = nil
  }

  ///   A response message indicating whether the
  ///   endorsement of the action was successful
  var response: Protos_Response {
    get {return _storage._response ?? Protos_Response()}
    set {_uniqueStorage()._response = newValue}
  }
  var hasResponse: Bool {
    return _storage._response != nil
  }
  mutating func clearResponse() {
    return _storage._response = nil
  }

  ///   The payload of response. It is the bytes of ProposalResponsePayload
  var payload: Data {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  ///   The endorsement of the proposal, basically
  ///   the endorser's signature over the payload
  var endorsement: Protos_Endorsement {
    get {return _storage._endorsement ?? Protos_Endorsement()}
    set {_uniqueStorage()._endorsement = newValue}
  }
  var hasEndorsement: Bool {
    return _storage._endorsement != nil
  }
  mutating func clearEndorsement() {
    return _storage._endorsement = nil
  }

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
      }
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularInt32Field(value: &_storage._version)
    case 2: try decoder.decodeSingularMessageField(value: &_storage._timestamp)
    case 4: try decoder.decodeSingularMessageField(value: &_storage._response)
    case 5: try decoder.decodeSingularBytesField(value: &_storage._payload)
    case 6: try decoder.decodeSingularMessageField(value: &_storage._endorsement)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._version != 0 {
        try visitor.visitSingularInt32Field(value: _storage._version, fieldNumber: 1)
      }
      if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._response {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._payload.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._payload, fieldNumber: 5)
      }
      if let v = _storage._endorsement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_ProposalResponse) -> Bool {
    return withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
      if _storage !== other_storage {
        if _storage._version != other_storage._version {return false}
        if _storage._timestamp != other_storage._timestamp {return false}
        if _storage._response != other_storage._response {return false}
        if _storage._payload != other_storage._payload {return false}
        if _storage._endorsement != other_storage._endorsement {return false}
      }
      return true
    }
  }
}

///   A response with a representation similar to an HTTP response that can
///   be used within another message.
struct Protos_Response: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Response"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "message"),
    3: .same(proto: "payload"),
  ]

  ///   A status code that should follow the HTTP status codes.
  var status: Int32 = 0

  ///   A message associated with the response code.
  var message: String = ""

  ///   A payload that can be used to include metadata with this response.
  var payload: Data = Data()

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularInt32Field(value: &status)
    case 2: try decoder.decodeSingularStringField(value: &message)
    case 3: try decoder.decodeSingularBytesField(value: &payload)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if status != 0 {
      try visitor.visitSingularInt32Field(value: status, fieldNumber: 1)
    }
    if !message.isEmpty {
      try visitor.visitSingularStringField(value: message, fieldNumber: 2)
    }
    if !payload.isEmpty {
      try visitor.visitSingularBytesField(value: payload, fieldNumber: 3)
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_Response) -> Bool {
    if status != other.status {return false}
    if message != other.message {return false}
    if payload != other.payload {return false}
    return true
  }
}

///   ProposalResponsePayload is the payload of a proposal response.  This message
///   is the "bridge" between the client's request and the endorser's action in
///   response to that request. Concretely, for chaincodes, it contains a hashed
///   representation of the proposal (proposalHash) and a representation of the
///   chaincode state changes and events inside the extension field.
struct Protos_ProposalResponsePayload: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProposalResponsePayload"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .unique(proto: "proposal_hash", json: "proposalHash"),
    2: .same(proto: "extension"),
  ]

  ///   Hash of the proposal that triggered this response. The hash is used to
  ///   link a response with its proposal, both for bookeeping purposes on an
  ///   asynchronous system and for security reasons (accountability,
  ///   non-repudiation). The hash usually covers the entire Proposal message
  ///   (byte-by-byte). However this implies that the hash can only be verified
  ///   if the entire proposal message is available when ProposalResponsePayload is
  ///   included in a transaction or stored in the ledger. For confidentiality
  ///   reasons, with chaincodes it might be undesirable to store the proposal
  ///   payload in the ledger.  If the type is CHAINCODE, this is handled by
  ///   separating the proposal's header and
  ///   the payload: the header is always hashed in its entirety whereas the
  ///   payload can either be hashed fully, or only its hash may be hashed, or
  ///   nothing from the payload can be hashed. The PayloadVisibility field in the
  ///   Header's extension controls to which extent the proposal payload is
  ///   "visible" in the sense that was just explained.
  var proposalHash: Data = Data()

  ///   Extension should be unmarshaled to a type-specific message. The type of
  ///   the extension in any proposal response depends on the type of the proposal
  ///   that the client selected when the proposal was initially sent out.  In
  ///   particular, this information is stored in the type field of a Header.  For
  ///   chaincode, it's a ChaincodeAction message
  var extension_p: Data = Data()

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularBytesField(value: &proposalHash)
    case 2: try decoder.decodeSingularBytesField(value: &extension_p)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !proposalHash.isEmpty {
      try visitor.visitSingularBytesField(value: proposalHash, fieldNumber: 1)
    }
    if !extension_p.isEmpty {
      try visitor.visitSingularBytesField(value: extension_p, fieldNumber: 2)
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_ProposalResponsePayload) -> Bool {
    if proposalHash != other.proposalHash {return false}
    if extension_p != other.extension_p {return false}
    return true
  }
}

///   An endorsement is a signature of an endorser over a proposal response.  By
///   producing an endorsement message, an endorser implicitly "approves" that
///   proposal response and the actions contained therein. When enough
///   endorsements have been collected, a transaction can be generated out of a
///   set of proposal responses.  Note that this message only contains an identity
///   and a signature but no signed payload. This is intentional because
///   endorsements are supposed to be collected in a transaction, and they are all
///   expected to endorse a single proposal response/action (many endorsements
///   over a single proposal response)
struct Protos_Endorsement: SwiftProtobuf.Proto3Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Endorsement"
  static let protoPackageName: String = "protos"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "endorser"),
    2: .same(proto: "signature"),
  ]

  ///   Identity of the endorser (e.g. its certificate)
  var endorser: Data = Data()

  ///   Signature of the payload included in ProposalResponse concatenated with
  ///   the endorser's certificate; ie, sign(ProposalResponse.payload + endorser)
  var signature: Data = Data()

  init() {}

  mutating func _protobuf_generated_decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      try decodeField(decoder: &decoder, fieldNumber: fieldNumber)
    }
  }

  mutating func _protobuf_generated_decodeField<D: SwiftProtobuf.Decoder>(decoder: inout D, fieldNumber: Int) throws {
    switch fieldNumber {
    case 1: try decoder.decodeSingularBytesField(value: &endorser)
    case 2: try decoder.decodeSingularBytesField(value: &signature)
    default: break
    }
  }

  func _protobuf_generated_traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !endorser.isEmpty {
      try visitor.visitSingularBytesField(value: endorser, fieldNumber: 1)
    }
    if !signature.isEmpty {
      try visitor.visitSingularBytesField(value: signature, fieldNumber: 2)
    }
  }

  func _protobuf_generated_isEqualTo(other: Protos_Endorsement) -> Bool {
    if endorser != other.endorser {return false}
    if signature != other.signature {return false}
    return true
  }
}
